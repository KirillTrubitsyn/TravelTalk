<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="theme-color" content="#FFF9F2">
<title>TravelTalk</title>
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/x-icon" href="icons/favicon.ico">
<link rel="icon" type="image/svg+xml" href="icons/icon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/traveltalk-icon-180.png">
<style>
/* ===== DESIGN TOKENS ===== */
:root {
  --bg: #FFF9F2;
  --surface: #FFFFFF;
  --surfaceAlt: #FFF3E6;
  --text: #1F2937;
  --muted: #6B7280;
  --border: rgba(31,41,55,0.08);
  --terracotta: #F26A3D;
  --terracottaDark: #D8572E;
  --sea: #1C8C7A;
  --seaSoft: rgba(28,140,122,0.12);
  --warning: #F59E0B;
  --success: #10B981;
  --focus: rgba(242,106,61,0.35);
  --cta: linear-gradient(90deg, #F26A3D 0%, #FFB15C 100%);
  --ctaShadow: 0 4px 12px rgba(242,106,61,0.25);
  --shadowSm: 0 1px 3px rgba(31,41,55,0.04);
  --shadowMd: 0 6px 18px rgba(31,41,55,0.06);
  --r12: 12px;
  --r16: 16px;
  --r20: 20px;
  --font: system-ui, -apple-system, 'Segoe UI', Roboto, Inter, Arial, sans-serif;
  --danger: #ef4444;
}

/* ===== RESET ===== */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html { font-size: 16px; }
body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  min-height: 100dvh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
  line-height: 1.5;
}

/* ===== APP SHELL ===== */
.app {
  max-width: 520px;
  margin: 0 auto;
  padding: 0 16px;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
}

@media (min-width: 480px) {
  .app { padding: 0 20px; }
}

/* ===== FOCUS ===== */
:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--focus);
}

/* ===== HEADER ===== */
.header {
  padding: 24px 0 18px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 64px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 10px;
}
.logo-icon {
  width: 48px;
  height: 48px;
  border-radius: 12px;
  object-fit: contain;
}
.logo-text {
  font-size: 19px;
  font-weight: 600;
  letter-spacing: -0.3px;
  color: var(--sea);
}
.logo-text span {
  color: var(--terracotta);
}
.voice-gender-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-radius: var(--r12);
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--muted);
  font-family: var(--font);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-height: 44px;
}
.voice-gender-btn:hover { background: var(--surfaceAlt); color: var(--text); }
.voice-gender-btn.male { border-color: var(--sea); color: var(--sea); }
.voice-gender-btn.female { border-color: var(--terracotta); color: var(--terracotta); }

/* ===== TABS / SEGMENTED CONTROL ===== */
.tabs {
  display: flex;
  gap: 0;
  margin-bottom: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r16);
  padding: 6px;
  box-shadow: var(--shadowMd);
}
.tab {
  flex: 1;
  padding: 10px 4px;
  border-radius: var(--r12);
  background: transparent;
  border: none;
  color: var(--muted);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  transition: all 0.2s;
  min-height: 44px;
}
.tab svg { width: 16px; height: 16px; }
.tab.active {
  background: var(--seaSoft);
  color: var(--sea);
  font-weight: 600;
}
.tab:not(.active):hover {
  color: var(--text);
  background: var(--surfaceAlt);
}

/* ===== LANGUAGE SELECTOR ===== */
.lang-bar {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 8px;
  box-shadow: var(--shadowMd);
  position: relative;
}
.lang-bar::before {
  content: '';
  position: absolute;
  top: 20%;
  bottom: 20%;
  left: 50%;
  width: 0;
  border-left: 2px dotted rgba(31,41,55,0.10);
  pointer-events: none;
  z-index: 0;
}
.lang-select-wrap {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}
.lang-flag {
  display: none;
  padding-left: 10px;
  pointer-events: none;
  flex-shrink: 0;
  line-height: 0;
}
@media (min-width: 480px) {
  .lang-flag { display: flex; align-items: center; }
}
.lang-select-wrap::after {
  content: '\25BE';
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--muted);
  font-size: 11px;
  pointer-events: none;
}
.lang-select {
  width: 100%;
  padding: 10px 8px;
  border-radius: var(--r12);
  border: none;
  background: transparent;
  color: var(--text);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  text-align: center;
}
.lang-select option {
  background: var(--surface);
  color: var(--text);
}
.lang-select-wrap.source .lang-select { color: var(--terracotta); }
.lang-select-wrap.target .lang-select { color: var(--sea); }

.lang-swap {
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: var(--surfaceAlt);
  color: var(--sea);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.3s;
  z-index: 1;
}
.lang-swap:hover {
  color: var(--terracotta);
  border-color: var(--terracotta);
  transform: rotate(180deg);
}

/* ===== CONTENT ===== */
.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-bottom: 32px;
}
.panel {
  display: none;
  flex-direction: column;
  gap: 16px;
  flex: 1;
}
.panel.active { display: flex; }

/* ===== BUTTONS ===== */
.btn {
  flex: 1;
  padding: 11px 16px;
  border-radius: var(--r12);
  border: none;
  font-family: var(--font);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-primary {
  background: var(--cta);
  color: #fff;
}
.btn-primary:hover { filter: brightness(1.05); }
.btn-ghost {
  background: var(--surfaceAlt);
  color: var(--muted);
  border: 1px solid var(--border);
}
.btn-ghost:hover { color: var(--text); }

/* ===== TEXT PANEL ===== */
.text-area-wrap {
  position: relative;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  overflow: hidden;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-shadow: var(--shadowMd);
}
.text-area-wrap:focus-within {
  border-color: rgba(242,106,61,0.25);
  box-shadow: var(--shadowMd), 0 0 0 3px var(--focus);
}
.text-area-wrap textarea {
  width: 100%;
  min-height: 110px;
  padding: 16px 20px;
  background: transparent;
  border: none;
  color: var(--text);
  font-family: var(--font);
  font-size: 15px;
  line-height: 1.5;
  resize: none;
  outline: none;
}
.text-area-wrap textarea::placeholder { color: var(--muted); }
.text-actions {
  display: flex;
  padding: 10px 16px;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid rgba(31,41,55,0.05);
}
.char-count {
  font-size: 11px;
  font-family: var(--font);
  font-variant-numeric: tabular-nums;
  color: var(--muted);
  background: var(--surfaceAlt);
  padding: 2px 8px;
  border-radius: 8px;
}
.text-attach-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: var(--r12);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--muted);
  cursor: pointer;
  transition: all 0.2s;
}
.text-attach-btn:hover { color: var(--sea); border-color: var(--sea); background: var(--surfaceAlt); }

.translate-btn {
  height: 44px;
  padding: 0 18px;
  border-radius: var(--r16);
  border: none;
  background: var(--cta);
  color: #fff;
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 150ms ease;
  box-shadow: var(--ctaShadow);
}
.translate-btn:hover {
  filter: brightness(1.05);
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(242,106,61,0.30);
}
.translate-btn:active { transform: translateY(1px); box-shadow: 0 2px 6px rgba(242,106,61,0.20); }
.translate-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }

/* ===== RESULT CARD ===== */
.result-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 20px;
  display: none;
  flex-direction: column;
  gap: 10px;
  animation: slideUp 0.3s ease;
  box-shadow: var(--shadowMd);
}
.result-card.visible { display: flex; }

@keyframes slideUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

.result-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--sea);
}
.result-text {
  font-size: 16px;
  line-height: 1.55;
  color: var(--text);
}
.result-actions { display: flex; gap: 8px; margin-top: 4px; }

.icon-btn {
  width: 44px;
  height: 44px;
  border-radius: var(--r16);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--sea);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}
.icon-btn:hover {
  background: var(--seaSoft);
  border-color: var(--sea);
}
.icon-btn svg { width: 16px; height: 16px; }
.icon-btn.speaking, .msg-play.speaking { color: var(--danger); border-color: var(--danger); cursor: pointer; }
.icon-btn.speaking svg, .msg-play.speaking svg { animation: pulse-speak 0.8s ease-in-out infinite; }
@keyframes pulse-speak { 0%,100% { opacity: 0.3; } 50% { opacity: 1; } }
.icon-btn.tts-loading, .msg-play.tts-loading { color: var(--sea); border-color: var(--sea); cursor: pointer; }
.icon-btn.tts-loading svg, .msg-play.tts-loading svg { animation: spin-load 0.8s linear infinite; }
@keyframes spin-load { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
.tts-global-stop {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  height: 44px;
  padding: 0 20px;
  border-radius: var(--r16);
  border: 2px solid var(--danger);
  background: var(--surface);
  color: var(--danger);
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: none;
  align-items: center;
  gap: 8px;
  box-shadow: var(--shadowMd);
  z-index: 199;
  opacity: 0;
  transition: all 0.3s;
}
.tts-global-stop.visible { display: inline-flex; opacity: 1; transform: translateX(-50%) translateY(0); }
.tts-global-stop:hover { background: rgba(239,68,68,0.1); box-shadow: 0 4px 16px rgba(239,68,68,0.25); }
.tts-global-stop:active { transform: translateX(-50%) translateY(1px); }
.tts-global-stop svg { width: 16px; height: 16px; }

.new-translate-btn {
  height: 36px;
  padding: 0 14px;
  border-radius: var(--r16);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--sea);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
}
.new-translate-btn:hover {
  background: var(--seaSoft);
  border-color: var(--sea);
}

/* ===== PHOTO PANEL ===== */
.photo-zone {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--r20);
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.photo-zone:hover {
  border-color: var(--terracotta);
  background: var(--surfaceAlt);
}
.photo-zone svg { width: 40px; height: 40px; color: var(--muted); }
.photo-zone .photo-title { font-size: 15px; font-weight: 500; color: var(--text); }
.photo-zone .photo-sub { font-size: 12px; color: var(--muted); }

.photo-preview {
  display: none;
  border-radius: var(--r20);
  overflow: hidden;
  border: 1px solid var(--border);
  position: relative;
  box-shadow: var(--shadowMd);
}
.photo-preview.visible { display: block; }
.photo-preview img { width: 100%; max-height: 250px; object-fit: cover; display: block; }
.photo-preview .photo-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 12px;
  background: linear-gradient(transparent, rgba(0,0,0,0.5));
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* ===== VOICE PANEL ===== */
.voice-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px 0;
  flex: 1;
  justify-content: center;
}
.mic-ring {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--surface);
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  box-shadow: var(--shadowMd);
}
.mic-ring::before {
  content: '';
  position: absolute;
  inset: -8px;
  border-radius: 50%;
  border: 1px solid transparent;
  transition: all 0.3s;
}
.mic-ring:hover { border-color: var(--terracotta); }
.mic-ring:hover::before { border-color: var(--focus); }
.mic-ring.recording {
  border-color: var(--danger);
  background: rgba(239,68,68,0.08);
  animation: pulse 1.5s ease infinite;
}
.mic-ring.recording::before { border-color: rgba(239,68,68,0.15); }

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.3); }
  50% { box-shadow: 0 0 0 16px rgba(239,68,68,0); }
}

.mic-ring svg { width: 36px; height: 36px; color: var(--muted); transition: color 0.3s; }
.mic-ring.recording svg { color: var(--danger); }

.voice-status { font-size: 14px; color: var(--muted); text-align: center; }
.voice-status.active { color: var(--danger); font-weight: 500; }
.voice-lang-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  color: var(--muted);
  cursor: pointer;
  padding: 4px 10px;
  border-radius: var(--r8);
  border: 1px solid var(--border);
  background: var(--bg);
  transition: all 0.2s;
  user-select: none;
}
.voice-lang-indicator:hover { border-color: var(--terracotta); color: var(--terracotta); }

.voice-transcript {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 20px;
  font-size: 15px;
  line-height: 1.5;
  display: none;
  min-height: 60px;
  color: var(--text);
  box-shadow: var(--shadowMd);
}
.voice-transcript.visible { display: block; }

/* ===== DIALOG PANEL ===== */
.dialog-area {
  display: flex;
  flex-direction: column;
  flex: 1;
  gap: 12px;
}
.dialog-messages {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 200px;
  max-height: calc(100dvh - 380px);
  padding: 4px;
}
.msg-bubble {
  max-width: 85%;
  padding: 12px 16px;
  border-radius: var(--r16);
  font-size: 14px;
  line-height: 1.5;
  animation: slideUp 0.25s ease;
  position: relative;
  box-shadow: var(--shadowSm);
}
.msg-source {
  align-self: flex-start;
  background: var(--surfaceAlt);
  border: 1px solid rgba(242,106,61,0.15);
  border-bottom-left-radius: 4px;
}
.msg-target {
  align-self: flex-end;
  background: var(--seaSoft);
  border: 1px solid rgba(28,140,122,0.15);
  border-bottom-right-radius: 4px;
}
.msg-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  margin-bottom: 4px;
}
.msg-source .msg-label { color: var(--terracotta); }
.msg-target .msg-label { color: var(--sea); }
.msg-text { color: var(--text); }

.msg-play {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: none;
  background: rgba(31,41,55,0.06);
  color: var(--muted);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}
.msg-play:hover { background: var(--seaSoft); color: var(--sea); }
.msg-play svg { width: 14px; height: 14px; }

.dialog-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  box-shadow: var(--shadowMd);
}
.dialog-mic {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  border: 2px solid var(--border);
  background: var(--bg);
  color: var(--muted);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.3s;
}
.dialog-mic:hover { border-color: var(--terracotta); color: var(--terracotta); }
.dialog-mic.recording {
  border-color: var(--danger);
  background: rgba(239,68,68,0.08);
  color: var(--danger);
  animation: pulse 1.5s ease infinite;
}
.dialog-mic svg { width: 22px; height: 22px; }
.dialog-lang-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: var(--muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: var(--r8);
  border: 1px solid var(--border);
  background: var(--bg);
  transition: all 0.2s;
  white-space: nowrap;
  user-select: none;
}
.dialog-lang-indicator:hover { border-color: var(--terracotta); color: var(--terracotta); }

.dialog-input {
  flex: 1;
  padding: 12px;
  border-radius: var(--r12);
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  font-family: var(--font);
  font-size: 14px;
  outline: none;
}
.dialog-input::placeholder { color: var(--muted); }
.dialog-input:focus { border-color: var(--terracotta); box-shadow: 0 0 0 3px var(--focus); }

.dialog-send {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: none;
  background: var(--cta);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 150ms ease;
  box-shadow: var(--ctaShadow);
}
.dialog-send:hover { filter: brightness(1.05); box-shadow: 0 6px 16px rgba(242,106,61,0.30); }
.dialog-send:active { transform: translateY(1px); box-shadow: 0 2px 6px rgba(242,106,61,0.20); }
.dialog-send svg { width: 18px; height: 18px; }

/* ===== AUTO-SPEAK TOGGLE ===== */
.auto-speak { display: flex; align-items: center; gap: 10px; padding: 8px 0; }
.auto-speak label { font-size: 13px; color: var(--muted); cursor: pointer; }
.toggle {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: var(--border);
  position: relative;
  cursor: pointer;
  transition: background 0.3s;
  border: none;
}
.toggle.on { background: var(--sea); }
.toggle::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: white;
  transition: transform 0.3s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}
.toggle.on::after { transform: translateX(18px); }

/* ===== LOADING DOTS ===== */
.loading-dots { display: inline-flex; gap: 4px; align-items: center; }
.loading-dots span {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--muted);
  animation: bounce 1.2s infinite;
}
.loading-dots span:nth-child(2) { animation-delay: 0.15s; }
.loading-dots span:nth-child(3) { animation-delay: 0.3s; }
@keyframes bounce {
  0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }
  40% { transform: scale(1); opacity: 1; }
}

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r12);
  padding: 10px 20px;
  font-size: 13px;
  color: var(--text);
  box-shadow: var(--shadowMd);
  opacity: 0;
  transition: all 0.3s;
  z-index: 200;
  pointer-events: none;
}
.toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

/* ===== STOP BUTTON ===== */
.stop-btn {
  height: 44px;
  padding: 0 18px;
  border-radius: var(--r16);
  border: 2px solid var(--danger);
  background: rgba(239,68,68,0.08);
  color: var(--danger);
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 150ms ease;
  display: none;
  align-items: center;
  gap: 6px;
}
.stop-btn.visible { display: inline-flex; }
.stop-btn:hover {
  background: rgba(239,68,68,0.15);
  box-shadow: 0 2px 8px rgba(239,68,68,0.2);
}
.stop-btn:active { transform: translateY(1px); }
.stop-btn svg { width: 16px; height: 16px; }

/* ===== FILE UPLOAD PANEL ===== */
.file-zone {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--r20);
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.file-zone:hover {
  border-color: var(--sea);
  background: var(--surfaceAlt);
}
.file-zone.dragover {
  border-color: var(--terracotta);
  background: rgba(242,106,61,0.06);
}
.file-zone svg { width: 40px; height: 40px; color: var(--muted); }
.file-zone .file-title { font-size: 15px; font-weight: 500; color: var(--text); }
.file-zone .file-sub { font-size: 12px; color: var(--muted); }
.file-zone .file-formats { font-size: 11px; color: var(--muted); margin-top: 4px; }

.file-info {
  display: none;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 16px 20px;
  box-shadow: var(--shadowMd);
  gap: 12px;
  flex-direction: column;
}
.file-info.visible { display: flex; }
.file-info-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.file-info-name {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
}
.file-info-name svg { width: 18px; height: 18px; color: var(--sea); flex-shrink: 0; }
.file-info-size {
  font-size: 11px;
  color: var(--muted);
}
.file-info-actions {
  display: flex;
  gap: 8px;
}
.file-content-preview {
  display: none;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: var(--r12);
  padding: 12px 16px;
  font-size: 13px;
  line-height: 1.5;
  color: var(--muted);
  max-height: 150px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
.file-content-preview.visible { display: block; }

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(31,41,55,0.12); border-radius: 2px; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
</head>
<body>

<div class="app">
  <div class="header">
    <div class="logo">
      <img class="logo-icon" src="icons/icon.svg" alt="T">
      <div class="logo-text">Travel<span>Talk</span></div>
    </div>
    <button class="voice-gender-btn" id="voiceGenderBtn" onclick="toggleVoiceGender()" title="Сменить голос">
      <svg id="voiceGenderIcon" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>
      <span id="voiceGenderLabel">Жен</span>
    </button>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="text">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
      Текст
    </button>
    <button class="tab" data-tab="photo">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
      Фото
    </button>
    <button class="tab" data-tab="voice">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
      Голос
    </button>
    <button class="tab" data-tab="dialog">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
      Диалог
    </button>
    <button class="tab" data-tab="file">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
      Файл
    </button>
  </div>

  <div class="lang-bar">
    <div class="lang-select-wrap source">
      <span class="lang-flag" id="langFromFlag"></span>
      <select class="lang-select" id="langFrom" onchange="updateLangs()">
        <option value="ru">Русский</option>
        <option value="pt-BR">Português</option>
        <option value="en">English</option>
        <option value="de">Deutsch</option>
        <option value="fr">Français</option>
      </select>
    </div>
    <button class="lang-swap" onclick="swapLangs()">
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
    </button>
    <div class="lang-select-wrap target">
      <span class="lang-flag" id="langToFlag"></span>
      <select class="lang-select" id="langTo" onchange="updateLangs()">
        <option value="en">English</option>
        <option value="pt-BR">Português</option>
        <option value="ru">Русский</option>
        <option value="de">Deutsch</option>
        <option value="fr">Français</option>
      </select>
    </div>
  </div>

  <div class="content">

    <!-- TEXT -->
    <div class="panel active" id="panel-text">
      <div class="text-area-wrap">
        <textarea id="textInput" placeholder="Введите текст для перевода..." oninput="updateCharCount()"></textarea>
        <div class="text-actions">
          <div style="display:flex;gap:8px;align-items:center">
            <span class="char-count" id="charCount">0</span>
            <button class="text-attach-btn" onclick="document.getElementById('textFileInput').click()" title="Загрузить текст из файла">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
            </button>
          </div>
          <input type="file" id="textFileInput" accept=".txt,.text,.html,.htm,.csv,.json,.md,.markdown,.xml,.srt,.sub,.vtt,.log,.ini,.cfg,.yaml,.yml,.tsv" style="display:none" onchange="handleTextFileUpload(event)">
          <div style="display:flex;gap:8px;align-items:center">
            <button class="stop-btn" id="textStopBtn" onclick="stopCurrentOperation()">
              <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              Стоп
            </button>
            <button class="translate-btn" id="textTranslateBtn" onclick="translateText()">Перевести</button>
          </div>
        </div>
      </div>
      <div class="result-card" id="textResult">
        <div class="result-label" id="textResultLabel">Перевод</div>
        <div class="result-text" id="textResultText"></div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('textResultText')" title="Копировать">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('textResultText', this)" title="Озвучить">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
          </button>
          <div style="flex:1"></div>
          <button class="new-translate-btn" onclick="clearTextForm()" title="Новый перевод">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            Новый перевод
          </button>
        </div>
      </div>
    </div>

    <!-- PHOTO -->
    <div class="panel" id="panel-photo">
      <div class="photo-zone" onclick="document.getElementById('photoInput').click()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
        <div class="photo-title">Сфотографировать или выбрать</div>
        <div class="photo-sub">Вывеска, меню, документ</div>
      </div>
      <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none" onchange="handlePhoto(event)">
      <div class="photo-preview" id="photoPreview">
        <img id="photoImg" src="" alt="">
        <div class="photo-overlay">
          <button class="btn btn-primary" id="photoTranslateBtn" style="flex:none;padding:8px 16px;font-size:12px" onclick="translatePhoto()">Распознать и перевести</button>
          <button class="stop-btn" id="photoStopBtn" onclick="stopCurrentOperation()" style="height:36px;padding:0 12px;font-size:12px">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
            Стоп
          </button>
          <button class="icon-btn" onclick="clearPhoto()" style="background:rgba(0,0,0,0.5);border:none">
            <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
      </div>
      <div class="result-card" id="photoOcrResult">
        <div class="result-label">Распознанный текст</div>
        <div class="result-text" id="photoOcrText"></div>
      </div>
      <div class="result-card" id="photoTransResult">
        <div class="result-label">Перевод</div>
        <div class="result-text" id="photoTransText"></div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('photoTransText')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('photoTransText', this)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- VOICE -->
    <div class="panel" id="panel-voice">
      <div class="voice-area">
        <div class="mic-ring" id="voiceMic" onclick="toggleVoiceRecording()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
        </div>
        <span class="voice-lang-indicator" id="voiceLangIndicator" onclick="toggleVoiceLang()" title="Нажмите, чтобы переключить язык записи"></span>
        <div class="voice-status" id="voiceStatus">Нажмите для записи</div>
        <div class="voice-transcript" id="voiceTranscript"></div>
        <div class="result-card" id="voiceResult">
          <div class="result-label">Перевод</div>
          <div class="result-text" id="voiceResultText"></div>
          <div class="result-actions">
            <button class="icon-btn" onclick="copyResult('voiceResultText')">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
            </button>
            <button class="icon-btn" onclick="speakResult('voiceResultText', this)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- FILE -->
    <div class="panel" id="panel-file">
      <div class="file-zone" id="fileZone" onclick="document.getElementById('fileInput').click()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
        <div class="file-title">Загрузить файл для перевода</div>
        <div class="file-sub">Перетащите файл сюда или нажмите</div>
        <div class="file-formats">.pdf, .docx, изображения, .txt, .html, .csv, .json, .md, .xml</div>
      </div>
      <input type="file" id="fileInput" accept=".txt,.text,.html,.htm,.csv,.json,.md,.markdown,.xml,.srt,.sub,.vtt,.log,.ini,.cfg,.yaml,.yml,.tsv,.pdf,.docx,.jpg,.jpeg,.png,.gif,.webp,.bmp,.tiff,.tif,.heic,.heif,.avif,.svg,image/*" style="display:none" onchange="handleFileUpload(event)">
      <div class="file-info" id="fileInfo">
        <div class="file-info-header">
          <div class="file-info-name">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
            <span id="fileName"></span>
          </div>
          <span class="file-info-size" id="fileSize"></span>
        </div>
        <div class="file-content-preview visible" id="filePreview"></div>
        <img id="fileImagePreview" src="" alt="" style="display:none;width:100%;max-height:200px;object-fit:contain;border-radius:var(--r12);border:1px solid var(--border)">
        <div class="file-info-actions">
          <button class="btn btn-primary" id="fileTranslateBtn" onclick="translateFile()" style="flex:1">Перевести файл</button>
          <button class="stop-btn" id="fileStopBtn" onclick="stopCurrentOperation()">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
            Стоп
          </button>
          <button class="btn btn-ghost" onclick="clearFile()" style="flex:none;padding:8px 16px">Убрать</button>
        </div>
      </div>
      <div class="result-card" id="fileResult">
        <div class="result-label" id="fileResultLabel">Перевод файла</div>
        <div class="result-text" id="fileResultText" style="white-space:pre-wrap"></div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('fileResultText')" title="Копировать">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="downloadTranslation()" title="Скачать перевод">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('fileResultText', this)" title="Озвучить">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- DIALOG -->
    <div class="panel" id="panel-dialog">
      <div class="dialog-area">
        <div class="auto-speak">
          <button class="toggle on" id="autoSpeakToggle" onclick="toggleAutoSpeak()"></button>
          <label onclick="toggleAutoSpeak()">Автоозвучка перевода</label>
        </div>
        <div class="dialog-messages" id="dialogMessages">
          <div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">
            Нажмите на микрофон и произнесите фразу.<br>Перевод будет озвучен автоматически.
          </div>
        </div>
        <div class="dialog-controls">
          <span class="dialog-lang-indicator" id="dialogLangIndicator" onclick="toggleDialogLang()" title="Нажмите, чтобы переключить язык записи"></span>
          <button class="dialog-mic" id="dialogMic" onclick="toggleDialogRecording()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
          </button>
          <input class="dialog-input" id="dialogInput" placeholder="Или введите текст..." onkeydown="if(event.key==='Enter')sendDialog()">
          <button class="dialog-send" onclick="sendDialog()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
          </button>
        </div>
      </div>
    </div>

  </div>
</div>


<div class="toast" id="toast"></div>
<button class="tts-global-stop" id="ttsGlobalStop" onclick="stopAudio()">
  <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
  Стоп
</button>

<script>
// ===== LANGUAGE CONFIG =====
const LANGS = {
  'ru':    { name: 'Русский',    flagCode: 'ru', speech: 'ru-RU',  tts: 'ru-RU' },
  'pt-BR': { name: 'Português',  flagCode: 'br', speech: 'pt-BR',  tts: 'pt-BR' },
  'en':    { name: 'English',    flagCode: 'gb', speech: 'en-US',  tts: 'en-US' },
  'de':    { name: 'Deutsch',    flagCode: 'de', speech: 'de-DE',  tts: 'de-DE' },
  'fr':    { name: 'Français',   flagCode: 'fr', speech: 'fr-FR',  tts: 'fr-FR' }
};
function flagImg(code, size) {
  size = size || 20;
  return '<img src="https://flagcdn.com/w40/' + code + '.png" width="' + size + '" height="' + Math.round(size * 0.75) + '" alt="" style="vertical-align:middle;border-radius:2px">';
}

const LANG_NAMES_FOR_PROMPT = {
  'ru': 'Russian', 'pt-BR': 'Brazilian Portuguese',
  'en': 'English', 'de': 'German', 'fr': 'French'
};

let sourceLang = 'ru';
let targetLang = 'en';
let autoSpeak = true;
let voiceRecording = false;
let dialogRecording = false;
let recognition = null;
let dialogFirstMessage = true;
let dialogNextLang = 'ru';
let voiceNextLang = 'ru';
let voiceGender = localStorage.getItem('traveltalk_voice') || 'female';

function getSourceName() { return LANG_NAMES_FOR_PROMPT[sourceLang]; }
function getTargetName() { return LANG_NAMES_FOR_PROMPT[targetLang]; }

// ===== INIT =====
document.addEventListener('DOMContentLoaded', () => {
  initTabs();
  updateLangs();
  updateVoiceGenderUI();
});

function toggleVoiceGender() {
  voiceGender = voiceGender === 'female' ? 'male' : 'female';
  localStorage.setItem('traveltalk_voice', voiceGender);
  updateVoiceGenderUI();
}

function updateVoiceGenderUI() {
  const btn = document.getElementById('voiceGenderBtn');
  const label = document.getElementById('voiceGenderLabel');
  btn.classList.remove('male', 'female');
  btn.classList.add(voiceGender);
  label.textContent = voiceGender === 'female' ? 'Жен' : 'Муж';
}

function initTabs() {
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
    });
  });
}

// ===== LANGUAGE =====
function updateLangs() {
  sourceLang = document.getElementById('langFrom').value;
  targetLang = document.getElementById('langTo').value;
  if (sourceLang === targetLang) {
    const keys = Object.keys(LANGS);
    const alt = keys.find(k => k !== sourceLang);
    targetLang = alt;
    document.getElementById('langTo').value = alt;
  }
  document.getElementById('langFromFlag').innerHTML = flagImg(LANGS[sourceLang].flagCode);
  document.getElementById('langToFlag').innerHTML = flagImg(LANGS[targetLang].flagCode);
  dialogNextLang = sourceLang;
  voiceNextLang = sourceLang;
  // Clear dialog history on language change
  dialogFirstMessage = true;
  const dialogContainer = document.getElementById('dialogMessages');
  if (dialogContainer) {
    dialogContainer.innerHTML = '<div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">Нажмите на микрофон и произнесите фразу.<br>Перевод будет озвучен автоматически.</div>';
  }
  // Clear voice mode results
  const voiceTranscript = document.getElementById('voiceTranscript');
  if (voiceTranscript) { voiceTranscript.textContent = ''; voiceTranscript.classList.remove('visible'); }
  const voiceResult = document.getElementById('voiceResult');
  if (voiceResult) { voiceResult.classList.remove('visible'); }
  updateDialogLangIndicator();
  updateVoiceLangIndicator();
}

function swapLangs() {
  const fromEl = document.getElementById('langFrom');
  const toEl = document.getElementById('langTo');
  const tmp = fromEl.value;
  fromEl.value = toEl.value;
  toEl.value = tmp;
  updateLangs();
}

function updateDialogLangIndicator() {
  const el = document.getElementById('dialogLangIndicator');
  if (!el) return;
  const lang = LANGS[dialogNextLang];
  if (!lang) return;
  el.innerHTML = flagImg(lang.flagCode, 16) + ' ' + lang.name;
}

function flipDialogLang() {
  dialogNextLang = (dialogNextLang === sourceLang) ? targetLang : sourceLang;
  updateDialogLangIndicator();
}

function toggleDialogLang() {
  flipDialogLang();
}

function updateVoiceLangIndicator() {
  const el = document.getElementById('voiceLangIndicator');
  if (!el) return;
  const lang = LANGS[voiceNextLang];
  if (!lang) return;
  el.innerHTML = flagImg(lang.flagCode, 16) + ' ' + lang.name;
}

function flipVoiceLang() {
  voiceNextLang = (voiceNextLang === sourceLang) ? targetLang : sourceLang;
  updateVoiceLangIndicator();
}

function toggleVoiceLang() {
  flipVoiceLang();
}

// ===== API =====
async function callTranslate(systemPrompt, userContent, maxTokens, signal) {
  const opts = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      system: systemPrompt,
      content: userContent,
      max_tokens: maxTokens || 1024
    })
  };
  if (signal) opts.signal = signal;

  const res = await fetch('/api/translate', opts);

  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'API error: ' + res.status);
  return data.text;
}

function getAutoTranslatePrompt() {
  return 'You are a professional translator. The user has a language pair: ' + getSourceName() + ' and ' + getTargetName() + '. Auto-detect the language of the input text. If it is ' + getSourceName() + ', translate to ' + getTargetName() + '. If it is ' + getTargetName() + ', translate to ' + getSourceName() + '. If it is neither, translate to ' + getTargetName() + '. IMPORTANT: Always provide a proper semantic translation of the meaning. Never transliterate or write words phonetically in another script. For example, German "Flughafen" must be translated to Russian "аэропорт", not transliterated as "Флюгхафен". Reply ONLY with this JSON: {"from":"LANG_CODE","text":"TRANSLATED_TEXT"} where LANG_CODE is one of: ' + Object.keys(LANGS).join(', ') + '. No markdown, no explanation, no conversation.';
}

function parseTranslateResult(raw) {
  try {
    const json = JSON.parse(raw);
    return { from: json.from, text: json.text };
  } catch (e) {
    return { from: sourceLang, text: raw };
  }
}

function getOtherLang(detectedLang) {
  if (detectedLang === sourceLang) return targetLang;
  if (detectedLang === targetLang) return sourceLang;
  return targetLang;
}

// ===== TEXT =====
function updateCharCount() {
  document.getElementById('charCount').textContent = document.getElementById('textInput').value.length;
}

function handleTextFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  const binaryExts = ['.docx', '.doc', '.xlsx', '.xls', '.pptx', '.ppt', '.pdf', '.zip', '.rar', '.7z', '.gz', '.tar', '.exe', '.bin', '.odt', '.ods', '.epub'];
  const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
  if (binaryExts.includes(ext)) {
    showToast('Формат ' + ext + ' не поддерживается. Используйте текстовые файлы (.txt, .html, .csv, .md и т.д.)');
    e.target.value = '';
    return;
  }

  const maxSize = 100 * 1024;
  if (file.size > maxSize) {
    showToast('Файл слишком большой (макс. 100 КБ)');
    e.target.value = '';
    return;
  }
  const reader = new FileReader();
  reader.onload = (ev) => {
    const text = ev.target.result;
    // Detect binary content (high ratio of non-printable characters)
    let nonPrintable = 0;
    for (let i = 0; i < Math.min(text.length, 1000); i++) {
      const c = text.charCodeAt(i);
      if (c < 32 && c !== 9 && c !== 10 && c !== 13) nonPrintable++;
    }
    if (nonPrintable > 20) {
      showToast('Файл содержит бинарные данные. Используйте текстовые файлы.');
      return;
    }
    document.getElementById('textInput').value = text;
    updateCharCount();
    showToast('Файл загружен: ' + file.name);
  };
  reader.readAsText(file, 'UTF-8');
  e.target.value = '';
}

async function translateText() {
  const text = document.getElementById('textInput').value.trim();
  if (!text) return;

  const btn = document.getElementById('textTranslateBtn');
  const stopBtn = document.getElementById('textStopBtn');
  btn.disabled = true; btn.textContent = '...';
  stopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    const raw = await callTranslate(
      getAutoTranslatePrompt() + ' If the text is a single word, also provide a brief pronunciation hint in parentheses using the script of the target language inside the "text" field.',
      text,
      1024,
      currentAbortController.signal
    );
    const r = parseTranslateResult(raw);
    const toLang = getOtherLang(r.from);
    document.getElementById('textResultText').textContent = r.text;
    document.getElementById('textResultText').dataset.lang = LANGS[toLang].tts;
    document.getElementById('textResultLabel').textContent = LANGS[toLang].name;
    document.getElementById('textResult').classList.add('visible');
  } catch (e) {
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  btn.disabled = false; btn.textContent = 'Перевести';
  stopBtn.classList.remove('visible');
  currentAbortController = null;
}

function clearTextForm() {
  stopAudio();
  document.getElementById('textInput').value = '';
  document.getElementById('textResultText').textContent = '';
  document.getElementById('textResult').classList.remove('visible');
  updateCharCount();
  document.getElementById('textInput').focus();
}

// ===== PHOTO =====
function handlePhoto(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    document.getElementById('photoImg').src = ev.target.result;
    document.getElementById('photoPreview').classList.add('visible');
    document.querySelector('.photo-zone').style.display = 'none';
  };
  reader.readAsDataURL(file);
}

function clearPhoto() {
  document.getElementById('photoPreview').classList.remove('visible');
  document.getElementById('photoOcrResult').classList.remove('visible');
  document.getElementById('photoTransResult').classList.remove('visible');
  document.querySelector('.photo-zone').style.display = 'flex';
  document.getElementById('photoInput').value = '';
}

async function translatePhoto() {
  const imgSrc = document.getElementById('photoImg').src;
  if (!imgSrc) return;
  showToast('Распознаю текст...');

  const photoBtn = document.getElementById('photoTranslateBtn');
  const photoStopBtn = document.getElementById('photoStopBtn');
  photoBtn.disabled = true; photoBtn.textContent = '...';
  photoStopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    const base64 = imgSrc.split(',')[1];
    const mediaType = imgSrc.split(';')[0].split(':')[1];

    const res = await fetch('/api/translate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        system: 'You are an OCR and translation assistant. First, extract ALL visible text from the image. Then translate it to ' + getTargetName() + '. Detect the source language automatically. IMPORTANT: Provide a proper semantic translation of the meaning, not a transliteration or phonetic transcription into another script. Format your response as:\nOCR: [extracted text]\nTRANSLATION: [translated text]',
        content: [
          { type: 'image', source: { type: 'base64', media_type: mediaType, data: base64 } },
          { type: 'text', text: 'Extract text from this image and translate it to ' + getTargetName() + '.' }
        ],
        max_tokens: 2048
      }),
      signal: currentAbortController.signal
    });

    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'API error');
    const text = data.text;
    const ocrMatch = text.match(/OCR:\s*([\s\S]*?)(?=TRANSLATION:|$)/i);
    const transMatch = text.match(/TRANSLATION:\s*([\s\S]*)/i);

    if (ocrMatch) {
      document.getElementById('photoOcrText').textContent = ocrMatch[1].trim();
      document.getElementById('photoOcrResult').classList.add('visible');
    }
    if (transMatch) {
      document.getElementById('photoTransText').textContent = transMatch[1].trim();
      document.getElementById('photoTransText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('photoTransResult').classList.add('visible');
    }
  } catch (e) {
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  photoBtn.disabled = false; photoBtn.textContent = 'Распознать и перевести';
  photoStopBtn.classList.remove('visible');
  currentAbortController = null;
}

// ===== SPEECH RECOGNITION =====
async function ensureMicPermission() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop());
    return true;
  } catch (e) {
    showToast('Разрешите доступ к микрофону в настройках браузера');
    return false;
  }
}

function getSpeechRecognition() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { showToast('Распознавание речи не поддерживается'); return null; }
  const r = new SR();
  r.continuous = false;
  r.interimResults = true;
  return r;
}

// ===== VOICE =====
async function toggleVoiceRecording() {
  const mic = document.getElementById('voiceMic');
  const status = document.getElementById('voiceStatus');

  if (voiceRecording) { if (recognition) recognition.stop(); return; }

  // Request microphone permission before starting recognition (required on mobile)
  if (!await ensureMicPermission()) return;

  // Stop any playing audio so it doesn't interfere with recording
  stopAudio();

  // Abort previous recognition instance to release mic resources
  if (recognition) {
    try { recognition.abort(); } catch(e) {}
    recognition = null;
  }

  recognition = getSpeechRecognition();
  if (!recognition) return;

  recognition.lang = LANGS[voiceNextLang].speech;
  voiceRecording = true;
  mic.classList.add('recording');
  status.textContent = 'Говорите...';
  status.classList.add('active');

  let finalText = '';

  recognition.onresult = (e) => {
    let interim = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) finalText += e.results[i][0].transcript;
      else interim += e.results[i][0].transcript;
    }
    document.getElementById('voiceTranscript').textContent = finalText + interim;
    document.getElementById('voiceTranscript').classList.add('visible');
  };

  recognition.onend = async () => {
    voiceRecording = false;
    mic.classList.remove('recording');
    status.textContent = 'Нажмите для записи';
    status.classList.remove('active');

    if (finalText.trim()) {
      currentAbortController = new AbortController();
      try {
        const raw = await callTranslate(getAutoTranslatePrompt(), finalText.trim(), 1024, currentAbortController.signal);
        const r = parseTranslateResult(raw);
        const toLang = getOtherLang(r.from);
        document.getElementById('voiceResultText').textContent = r.text;
        document.getElementById('voiceResultText').dataset.lang = LANGS[toLang].tts;
        document.getElementById('voiceResult').classList.add('visible');
        flipVoiceLang();
      } catch (e) {
        if (e.name !== 'AbortError') { showToast('Ошибка: ' + e.message); }
      }
      currentAbortController = null;
    }
  };

  recognition.onerror = (e) => {
    voiceRecording = false;
    mic.classList.remove('recording');
    if (e.error === 'not-allowed') {
      status.textContent = 'Нет доступа к микрофону';
    } else {
      status.textContent = 'Ошибка: ' + e.error;
    }
    status.classList.remove('active');
  };

  recognition.start();
}

// ===== DIALOG =====
function toggleAutoSpeak() {
  autoSpeak = !autoSpeak;
  document.getElementById('autoSpeakToggle').classList.toggle('on', autoSpeak);
}

function addDialogMessage(text, langCode, autoPlay) {
  const container = document.getElementById('dialogMessages');
  if (dialogFirstMessage) { container.innerHTML = ''; dialogFirstMessage = false; }

  const lang = LANGS[langCode];
  const isSource = (langCode === sourceLang);
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble ' + (isSource ? 'msg-source' : 'msg-target');

  const escapedText = text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');

  bubble.innerHTML =
    '<div class="msg-label">' + flagImg(lang.flagCode, 16) + ' ' + lang.name + '</div>' +
    '<div class="msg-text">' + text + '</div>' +
    '<button class="msg-play" onclick="speakText(\'' + escapedText + '\', \'' + lang.tts + '\', this)">' +
    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg></button>';

  container.appendChild(bubble);
  container.scrollTop = container.scrollHeight;

  if (autoPlay && autoSpeak) {
    const playBtn = bubble.querySelector('.msg-play');
    speakText(text, lang.tts, playBtn);
  }
}

function addLoadingBubble() {
  const container = document.getElementById('dialogMessages');
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble msg-target';
  bubble.id = 'loadingBubble';
  bubble.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
  container.appendChild(bubble);
  container.scrollTop = container.scrollHeight;
}

function removeLoadingBubble() {
  const el = document.getElementById('loadingBubble');
  if (el) el.remove();
}

async function sendDialog() {
  const input = document.getElementById('dialogInput');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';

  addLoadingBubble();
  currentAbortController = new AbortController();

  try {
    const raw = await callTranslate(
      getAutoTranslatePrompt() + ' Make the translation sound natural and fluent.',
      text,
      1024,
      currentAbortController.signal
    );
    const r = parseTranslateResult(raw);
    const fromLang = r.from || sourceLang;
    const toLang = getOtherLang(fromLang);
    removeLoadingBubble();
    addDialogMessage(text, fromLang, false);
    addDialogMessage(r.text, toLang, true);
    flipDialogLang();
  } catch (e) {
    removeLoadingBubble();
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  currentAbortController = null;
}

async function toggleDialogRecording() {
  const mic = document.getElementById('dialogMic');

  if (dialogRecording) {
    if (recognition) recognition.stop();
    return;
  }

  // Request microphone permission before starting recognition (required on mobile)
  if (!await ensureMicPermission()) return;

  // Stop any playing audio so it doesn't interfere with recording
  stopAudio();

  // Abort any in-flight translation from a previous recording
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
    removeLoadingBubble();
  }

  // Abort previous recognition instance to release mic resources
  if (recognition) {
    try { recognition.abort(); } catch(e) {}
    recognition = null;
  }

  recognition = getSpeechRecognition();
  if (!recognition) return;

  // Use continuous mode so recognition doesn't cut off mid-phrase on mobile;
  // user explicitly stops by tapping mic again
  recognition.continuous = true;
  recognition.lang = LANGS[dialogNextLang].speech;
  dialogRecording = true;
  mic.classList.add('recording');

  let finalText = '';

  recognition.onresult = (e) => {
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) finalText += e.results[i][0].transcript;
    }
  };

  recognition.onend = async () => {
    dialogRecording = false;
    mic.classList.remove('recording');

    if (finalText.trim()) {
      addLoadingBubble();
      currentAbortController = new AbortController();

      try {
        const raw = await callTranslate(
          getAutoTranslatePrompt() + ' Make the translation sound natural and fluent.',
          finalText.trim(),
          1024,
          currentAbortController.signal
        );
        const r = parseTranslateResult(raw);
        const fromLang = r.from || dialogNextLang;
        const toLang = getOtherLang(fromLang);
        removeLoadingBubble();
        addDialogMessage(finalText.trim(), fromLang, false);
        addDialogMessage(r.text, toLang, true);
        flipDialogLang();
      } catch (e) {
        removeLoadingBubble();
        if (e.name !== 'AbortError') {
          showToast('Ошибка: ' + e.message);
        }
      }

      currentAbortController = null;
    }
  };

  recognition.onerror = (e) => {
    dialogRecording = false;
    mic.classList.remove('recording');
    if (e.error === 'not-allowed') {
      showToast('Разрешите доступ к микрофону в настройках браузера');
    } else if (e.error !== 'aborted') {
      showToast('Ошибка записи: ' + e.error);
    }
  };

  recognition.start();
}

// ===== TTS (direct-URL playback for mobile compatibility) =====
let ttsLoading = false;

// Persistent Audio element – reused across plays.
let _audioEl = null;
function getAudioEl() {
  if (!_audioEl) {
    _audioEl = new Audio();
    _audioEl.setAttribute('playsinline', '');
  }
  return _audioEl;
}

function clearSpeakingState() {
  document.querySelectorAll('.speaking').forEach(el => el.classList.remove('speaking'));
  document.querySelectorAll('.tts-loading').forEach(el => el.classList.remove('tts-loading'));
  const g = document.getElementById('ttsGlobalStop');
  if (g) g.classList.remove('visible');
}

function showGlobalStop() {
  const g = document.getElementById('ttsGlobalStop');
  if (g) g.classList.add('visible');
}

async function speakText(text, lang, btn) {
  const audio = getAudioEl();
  // Toggle: if already playing or loading, stop
  if (ttsLoading || (!audio.paused && !audio.ended) || (window.speechSynthesis && window.speechSynthesis.speaking)) {
    stopAudio();
    return;
  }

  stopAudio();
  clearSpeakingState();

  const ttsLang = lang || 'en-US';

  if (btn) btn.classList.add('tts-loading');
  ttsLoading = true;
  showGlobalStop();

  audio.onended = () => clearSpeakingState();
  audio.onerror = () => {
    ttsLoading = false;
    clearSpeakingState();
    showToast('Ошибка озвучки');
    fallbackSpeechSynthesis(text, ttsLang, btn);
  };

  // Set audio.src to a direct GET URL so the browser handles the
  // network request internally.  audio.play() is called synchronously
  // inside the user-gesture context — no async gap — so iOS / Android
  // allow playback without unlock hacks.  HTTP cache (max-age=86400)
  // makes repeated plays instant.
  const params = new URLSearchParams({ text, voice: voiceGender, lang: ttsLang });
  audio.src = '/api/tts?' + params.toString();

  try {
    await audio.play();
    // Playback started — switch loading → speaking
    if (btn) { btn.classList.remove('tts-loading'); btn.classList.add('speaking'); }
    ttsLoading = false;
    showGlobalStop();
  } catch (e) {
    ttsLoading = false;
    if (e.name === 'AbortError') {
      clearSpeakingState();
      return;
    }
    console.warn('[TTS] play() failed:', e.name, e.message);
    showToast('Ошибка: ' + e.name);
    clearSpeakingState();
    fallbackSpeechSynthesis(text, ttsLang, btn);
  }
}

function fallbackSpeechSynthesis(text, ttsLang, btn) {
  if (!('speechSynthesis' in window)) return;
  const u = new SpeechSynthesisUtterance(text);
  u.lang = ttsLang; u.rate = 0.9;
  const baseLang = ttsLang.split('-')[0];
  const voices = window.speechSynthesis.getVoices();
  const match = voices.find(v => v.lang === ttsLang && v.name.includes('Google'))
    || voices.find(v => v.lang === ttsLang)
    || voices.find(v => v.lang.startsWith(baseLang + '-') && v.name.includes('Google'))
    || voices.find(v => v.lang.startsWith(baseLang + '-'))
    || voices.find(v => v.lang.startsWith(baseLang));
  if (match) {
    u.voice = match; u.lang = match.lang;
    console.log('[TTS] Browser voice:', match.name, match.lang);
  } else {
    console.warn('[TTS] No voice found for', ttsLang, '— available:', voices.map(v => v.lang + ':' + v.name).join(', '));
    clearSpeakingState();
    showToast('Голос для этого языка недоступен');
    return;
  }
  u.onend = () => clearSpeakingState();
  if (btn) btn.classList.add('speaking');
  showGlobalStop();
  window.speechSynthesis.speak(u);
}

function speakResult(elementId, btn) {
  const el = document.getElementById(elementId);
  const text = el.textContent;
  const lang = el.dataset.lang || LANGS[targetLang].tts;
  speakText(text, lang, btn);
}

if ('speechSynthesis' in window) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
}

// ===== UTILS =====
function copyResult(elementId) {
  const text = document.getElementById(elementId).textContent;
  navigator.clipboard.writeText(text).then(() => showToast('Скопировано'));
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('visible');
  setTimeout(() => t.classList.remove('visible'), 2500);
}

// ===== ABORT CONTROLLER FOR STOPPING =====
let currentAbortController = null;

function stopCurrentOperation() {
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
  }
  stopAudio();
  showToast('Остановлено');
}

function stopAudio() {
  ttsLoading = false;
  const audio = getAudioEl();
  audio.pause();
  audio.removeAttribute('src');
  audio.load();  // cancels any pending network request
  if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  clearSpeakingState();
}

// ===== FILE UPLOAD =====
let uploadedFileContent = '';
let uploadedFileName = '';
let uploadedFileType = 'text'; // 'text', 'image', 'pdf'
let uploadedFileBase64 = '';
let uploadedFileMediaType = '';

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' Б';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' КБ';
  return (bytes / (1024 * 1024)).toFixed(1) + ' МБ';
}

function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
  const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg', '.tiff', '.tif', '.ico', '.heic', '.heif', '.avif'];
  const unsupportedExts = ['.doc', '.xlsx', '.xls', '.pptx', '.ppt', '.zip', '.rar', '.7z', '.gz', '.tar', '.exe', '.bin', '.odt', '.ods', '.epub'];

  if (unsupportedExts.includes(ext)) {
    showToast('Формат ' + ext + ' не поддерживается.');
    return;
  }

  const isImage = imageExts.includes(ext) || file.type.startsWith('image/');
  const isPdf = ext === '.pdf';
  const isDocx = ext === '.docx';
  const isBinary = isImage || isPdf || isDocx;

  const maxSize = isBinary ? 10 * 1024 * 1024 : 100 * 1024;
  const maxLabel = isBinary ? '10 МБ' : '100 КБ';

  if (file.size > maxSize) {
    showToast('Файл слишком большой (макс. ' + maxLabel + ')');
    return;
  }

  if (isImage) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      const dataUrl = ev.target.result;
      uploadedFileType = 'image';
      uploadedFileBase64 = dataUrl.split(',')[1];
      uploadedFileMediaType = dataUrl.split(';')[0].split(':')[1];
      uploadedFileName = file.name;
      uploadedFileContent = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').src = dataUrl;
      document.getElementById('fileImagePreview').style.display = 'block';
      document.getElementById('filePreview').classList.remove('visible');
    };
    reader.readAsDataURL(file);
  } else if (isPdf) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      const dataUrl = ev.target.result;
      uploadedFileType = 'pdf';
      uploadedFileBase64 = dataUrl.split(',')[1];
      uploadedFileMediaType = 'application/pdf';
      uploadedFileName = file.name;
      uploadedFileContent = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').style.display = 'none';
      document.getElementById('filePreview').textContent = 'PDF документ — ' + formatFileSize(file.size);
      document.getElementById('filePreview').classList.add('visible');
    };
    reader.readAsDataURL(file);
  } else if (isDocx) {
    const reader = new FileReader();
    reader.onload = async (ev) => {
      try {
        if (typeof mammoth === 'undefined') {
          showToast('Библиотека для DOCX не загружена. Проверьте соединение.');
          return;
        }
        const result = await mammoth.extractRawText({ arrayBuffer: ev.target.result });
        const text = result.value;
        if (!text.trim()) {
          showToast('Не удалось извлечь текст из документа');
          return;
        }
        uploadedFileType = 'text';
        uploadedFileContent = text;
        uploadedFileName = file.name;
        uploadedFileBase64 = '';
        uploadedFileMediaType = '';
        showFileInfo(file.name, file.size);
        document.getElementById('fileImagePreview').style.display = 'none';
        const preview = text.substring(0, 500);
        document.getElementById('filePreview').textContent = preview + (text.length > 500 ? '...' : '');
        document.getElementById('filePreview').classList.add('visible');
      } catch (err) {
        showToast('Ошибка чтения DOCX: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
  } else {
    // Text files
    const reader = new FileReader();
    reader.onload = (ev) => {
      const text = ev.target.result;
      let nonPrintable = 0;
      for (let i = 0; i < Math.min(text.length, 1000); i++) {
        const c = text.charCodeAt(i);
        if (c < 32 && c !== 9 && c !== 10 && c !== 13) nonPrintable++;
      }
      if (nonPrintable > 20) {
        showToast('Файл содержит бинарные данные.');
        return;
      }
      uploadedFileType = 'text';
      uploadedFileContent = text;
      uploadedFileName = file.name;
      uploadedFileBase64 = '';
      uploadedFileMediaType = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').style.display = 'none';
      const preview = text.substring(0, 500);
      document.getElementById('filePreview').textContent = preview + (text.length > 500 ? '...' : '');
      document.getElementById('filePreview').classList.add('visible');
    };
    reader.readAsText(file, 'UTF-8');
  }
}

function showFileInfo(name, size) {
  document.getElementById('fileName').textContent = name;
  document.getElementById('fileSize').textContent = formatFileSize(size);
  document.getElementById('fileInfo').classList.add('visible');
  document.getElementById('fileZone').style.display = 'none';
  document.getElementById('fileResult').classList.remove('visible');
}

function clearFile() {
  uploadedFileContent = '';
  uploadedFileName = '';
  uploadedFileType = 'text';
  uploadedFileBase64 = '';
  uploadedFileMediaType = '';
  document.getElementById('fileInfo').classList.remove('visible');
  document.getElementById('fileResult').classList.remove('visible');
  document.getElementById('fileZone').style.display = 'flex';
  document.getElementById('fileInput').value = '';
  document.getElementById('fileImagePreview').style.display = 'none';
}

async function translateFile() {
  if (uploadedFileType === 'text' && !uploadedFileContent) return;
  if ((uploadedFileType === 'image' || uploadedFileType === 'pdf') && !uploadedFileBase64) return;

  const btn = document.getElementById('fileTranslateBtn');
  const stopBtn = document.getElementById('fileStopBtn');
  btn.disabled = true;
  btn.textContent = 'Перевожу...';
  stopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    if (uploadedFileType === 'image') {
      const res = await fetch('/api/translate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          system: 'You are an OCR and translation assistant. Extract ALL visible text from the image. Then translate the extracted text to ' + getTargetName() + '. Detect the source language automatically. IMPORTANT: Provide a proper semantic translation, not transliteration. Reply with ONLY the translated text, no explanations or labels.',
          content: [
            { type: 'image', source: { type: 'base64', media_type: uploadedFileMediaType, data: uploadedFileBase64 } },
            { type: 'text', text: 'Extract all text from this image and translate it to ' + getTargetName() + '. Reply with ONLY the translated text.' }
          ],
          max_tokens: 4096
        }),
        signal: currentAbortController.signal
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'API error');
      document.getElementById('fileResultText').textContent = data.text;
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');

    } else if (uploadedFileType === 'pdf') {
      const res = await fetch('/api/translate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          system: 'You are a document translation assistant. Extract ALL text from this PDF document. Then translate it to ' + getTargetName() + '. Detect the source language automatically. Keep the structure and formatting. IMPORTANT: Provide a proper semantic translation, not transliteration. Reply with ONLY the translated text, no explanations or labels.',
          content: [
            { type: 'document', source: { type: 'base64', media_type: 'application/pdf', data: uploadedFileBase64 } },
            { type: 'text', text: 'Extract all text from this PDF and translate it to ' + getTargetName() + '. Reply with ONLY the translated text.' }
          ],
          max_tokens: 4096
        }),
        signal: currentAbortController.signal
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'API error');
      document.getElementById('fileResultText').textContent = data.text;
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');

    } else {
      // Text file — chunked translation
      const maxChunkSize = 2000;
      const chunks = [];
      let text = uploadedFileContent;

      if (text.length <= maxChunkSize) {
        chunks.push(text);
      } else {
        const lines = text.split('\n');
        let current = '';
        for (const line of lines) {
          if (current.length + line.length + 1 > maxChunkSize && current.length > 0) {
            chunks.push(current);
            current = line;
          } else {
            current += (current ? '\n' : '') + line;
          }
        }
        if (current) chunks.push(current);
      }

      const results = [];
      for (let i = 0; i < chunks.length; i++) {
        if (currentAbortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');

        if (chunks.length > 1) {
          btn.textContent = 'Часть ' + (i + 1) + '/' + chunks.length + '...';
        }

        const res = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            system: 'You are a professional translator. Translate the following text from ' + getSourceName() + ' to ' + getTargetName() + '. Keep the original formatting (line breaks, indentation, structure). Translate ONLY the text content, preserving any markup tags, code, or special characters. IMPORTANT: Provide a proper semantic translation, not a transliteration or phonetic transcription into another script. Reply with ONLY the translated text, no explanations.',
            content: chunks[i],
            max_tokens: 4096
          }),
          signal: currentAbortController.signal
        });

        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'API error: ' + res.status);
        results.push(data.text);
      }

      document.getElementById('fileResultText').textContent = results.join('\n');
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      showToast('Перевод остановлен');
    } else {
      showToast('Ошибка: ' + e.message);
    }
  }

  btn.disabled = false;
  btn.textContent = 'Перевести файл';
  stopBtn.classList.remove('visible');
  currentAbortController = null;
}

function downloadTranslation() {
  const text = document.getElementById('fileResultText').textContent;
  if (!text) return;

  const ext = uploadedFileName.includes('.') ? uploadedFileName.substring(uploadedFileName.lastIndexOf('.')) : '.txt';
  const baseName = uploadedFileName.includes('.') ? uploadedFileName.substring(0, uploadedFileName.lastIndexOf('.')) : uploadedFileName;
  const newName = baseName + '_' + targetLang + ext;

  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = newName;
  a.click();
  URL.revokeObjectURL(url);
  showToast('Файл скачан');
}

// Drag and drop for file zone
document.addEventListener('DOMContentLoaded', () => {
  const zone = document.getElementById('fileZone');
  if (!zone) return;

  zone.addEventListener('dragover', (e) => {
    e.preventDefault();
    zone.classList.add('dragover');
  });
  zone.addEventListener('dragleave', () => {
    zone.classList.remove('dragover');
  });
  zone.addEventListener('drop', (e) => {
    e.preventDefault();
    zone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) {
      // Create a synthetic event for handleFileUpload
      const dt = new DataTransfer();
      dt.items.add(file);
      document.getElementById('fileInput').files = dt.files;
      handleFileUpload({ target: { files: [file] } });
    }
  });
});

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
