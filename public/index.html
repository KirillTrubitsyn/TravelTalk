<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="theme-color" content="#FFF9F2">
<title>TravelTalk</title>
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/x-icon" href="icons/favicon.ico">
<link rel="icon" type="image/svg+xml" href="icons/icon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/traveltalk-icon-180.png">
<style>
/* ===== DESIGN TOKENS ===== */
:root {
  --bg: #FFF9F2;
  --surface: #FFFFFF;
  --surfaceAlt: #FFF3E6;
  --text: #1F2937;
  --muted: #6B7280;
  --border: rgba(31,41,55,0.08);
  --terracotta: #F26A3D;
  --terracottaDark: #D8572E;
  --sea: #1C8C7A;
  --seaSoft: rgba(28,140,122,0.12);
  --warning: #F59E0B;
  --success: #10B981;
  --focus: rgba(242,106,61,0.35);
  --cta: linear-gradient(90deg, #F26A3D 0%, #FFB15C 100%);
  --ctaShadow: 0 4px 12px rgba(242,106,61,0.25);
  --shadowSm: 0 1px 3px rgba(31,41,55,0.04);
  --shadowMd: 0 6px 18px rgba(31,41,55,0.06);
  --r12: 12px;
  --r16: 16px;
  --r20: 20px;
  --font: system-ui, -apple-system, 'Segoe UI', Roboto, Inter, Arial, sans-serif;
  --danger: #ef4444;
}

/* ===== RESET ===== */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html { font-size: 16px; }
body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  min-height: 100dvh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
  line-height: 1.5;
}

/* ===== APP SHELL ===== */
.app {
  max-width: 520px;
  margin: 0 auto;
  padding: 0 16px;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
}

@media (min-width: 480px) {
  .app { padding: 0 20px; }
}

/* ===== FOCUS ===== */
:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--focus);
}

/* ===== HEADER ===== */
.header {
  padding: 24px 0 18px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 64px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 10px;
}
.logo-icon {
  width: 48px;
  height: 48px;
  border-radius: 12px;
  object-fit: contain;
}
.logo-text {
  font-size: 19px;
  font-weight: 600;
  letter-spacing: -0.3px;
  color: var(--sea);
}
.logo-text span {
  color: var(--terracotta);
}
.voice-gender-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-radius: var(--r12);
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--muted);
  font-family: var(--font);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-height: 44px;
}
.voice-gender-btn:hover { background: var(--surfaceAlt); color: var(--text); }
.voice-gender-btn.male { border-color: var(--sea); color: var(--sea); }
.voice-gender-btn.female { border-color: var(--terracotta); color: var(--terracotta); }

/* ===== TABS / SEGMENTED CONTROL ===== */
.tabs {
  display: flex;
  gap: 0;
  margin-bottom: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r16);
  padding: 6px;
  box-shadow: var(--shadowMd);
}
.tab {
  flex: 1;
  padding: 10px 4px;
  border-radius: var(--r12);
  background: transparent;
  border: none;
  color: var(--muted);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  transition: all 0.2s;
  min-height: 44px;
}
.tab svg { width: 16px; height: 16px; }
.tab.active {
  background: var(--seaSoft);
  color: var(--sea);
  font-weight: 600;
}
.tab:not(.active):hover {
  color: var(--text);
  background: var(--surfaceAlt);
}

/* ===== LANGUAGE SELECTOR ===== */
.lang-bar {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 8px;
  box-shadow: var(--shadowMd);
  position: relative;
}
.lang-bar::before {
  content: '';
  position: absolute;
  top: 20%;
  bottom: 20%;
  left: 50%;
  width: 0;
  border-left: 2px dotted rgba(31,41,55,0.10);
  pointer-events: none;
  z-index: 0;
}
.lang-select-wrap {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}
.lang-flag {
  display: flex;
  align-items: center;
  padding: 10px 6px 10px 10px;
  pointer-events: none;
  flex-shrink: 0;
  line-height: 0;
}
.lang-label {
  pointer-events: none;
  font-family: var(--font);
  font-size: 13px;
  font-weight: 500;
  white-space: nowrap;
}
.lang-select-wrap.source .lang-label { color: var(--terracotta); }
.lang-select-wrap.target .lang-label { color: var(--sea); }
.lang-select {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
  border: none;
  background: transparent;
}
.lang-select option {
  background: var(--surface);
  color: var(--text);
}

.lang-swap {
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: var(--surfaceAlt);
  color: var(--sea);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.3s;
  z-index: 1;
}
.lang-swap:hover {
  color: var(--terracotta);
  border-color: var(--terracotta);
  transform: rotate(180deg);
}

/* ===== CONTENT ===== */
.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-bottom: 32px;
}
.panel {
  display: none;
  flex-direction: column;
  gap: 16px;
  flex: 1;
}
.panel.active { display: flex; }

/* ===== BUTTONS ===== */
.btn {
  flex: 1;
  padding: 11px 16px;
  border-radius: var(--r12);
  border: none;
  font-family: var(--font);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-primary {
  background: var(--cta);
  color: #fff;
}
.btn-primary:hover { filter: brightness(1.05); }
.btn-ghost {
  background: var(--surfaceAlt);
  color: var(--muted);
  border: 1px solid var(--border);
}
.btn-ghost:hover { color: var(--text); }

/* ===== TEXT PANEL ===== */
.text-area-wrap {
  position: relative;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  overflow: hidden;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-shadow: var(--shadowMd);
}
.text-area-wrap:focus-within {
  border-color: rgba(242,106,61,0.25);
  box-shadow: var(--shadowMd), 0 0 0 3px var(--focus);
}
.text-area-wrap textarea {
  width: 100%;
  min-height: 110px;
  padding: 16px 20px;
  background: transparent;
  border: none;
  color: var(--text);
  font-family: var(--font);
  font-size: 15px;
  line-height: 1.5;
  resize: none;
  outline: none;
}
.text-area-wrap textarea::placeholder { color: var(--muted); }
.text-actions {
  display: flex;
  padding: 10px 16px;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid rgba(31,41,55,0.05);
}
.char-count {
  font-size: 11px;
  font-family: var(--font);
  font-variant-numeric: tabular-nums;
  color: var(--muted);
  background: var(--surfaceAlt);
  padding: 2px 8px;
  border-radius: 8px;
}

.translate-btn {
  height: 44px;
  padding: 0 18px;
  border-radius: var(--r16);
  border: none;
  background: var(--cta);
  color: #fff;
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 150ms ease;
  box-shadow: var(--ctaShadow);
}
.translate-btn:hover {
  filter: brightness(1.05);
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(242,106,61,0.30);
}
.translate-btn:active { transform: translateY(1px); box-shadow: 0 2px 6px rgba(242,106,61,0.20); }
.translate-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }

/* ===== RESULT CARD ===== */
.result-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 20px;
  display: none;
  flex-direction: column;
  gap: 10px;
  animation: slideUp 0.3s ease;
  box-shadow: var(--shadowMd);
}
.result-card.visible { display: flex; }

@keyframes slideUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

.result-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--sea);
}
.result-text {
  font-size: 16px;
  line-height: 1.55;
  color: var(--text);
}
.result-actions { display: flex; gap: 8px; margin-top: 4px; }

/* ===== EXAMPLES SECTION ===== */
.result-examples {
  display: none;
  flex-direction: column;
  gap: 0;
  margin-top: 8px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}
.result-examples.visible { display: flex; }
.result-examples-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--muted);
  margin-bottom: 8px;
}
.example-item {
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.example-item + .example-item {
  border-top: 1px dashed var(--border);
}
.example-source {
  font-size: 14px;
  line-height: 1.45;
  color: var(--text);
}
.example-source b {
  color: var(--terracotta);
  font-weight: 600;
}
.example-translation {
  font-size: 13px;
  line-height: 1.45;
  color: var(--muted);
}
.example-translation b {
  color: var(--sea);
  font-weight: 600;
}

.icon-btn {
  width: 44px;
  height: 44px;
  border-radius: var(--r16);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--sea);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}
.icon-btn:hover {
  background: var(--seaSoft);
  border-color: var(--sea);
}
.icon-btn svg { width: 16px; height: 16px; }
.icon-btn.speaking, .msg-play.speaking { color: var(--danger); border-color: var(--danger); cursor: pointer; }
.icon-btn.speaking svg, .msg-play.speaking svg { animation: pulse-speak 0.8s ease-in-out infinite; }
@keyframes pulse-speak { 0%,100% { opacity: 0.3; } 50% { opacity: 1; } }
.tts-global-stop {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  height: 44px;
  padding: 0 20px;
  border-radius: var(--r16);
  border: 2px solid var(--danger);
  background: var(--surface);
  color: var(--danger);
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: none;
  align-items: center;
  gap: 8px;
  box-shadow: var(--shadowMd);
  z-index: 199;
  opacity: 0;
  transition: all 0.3s;
}
.tts-global-stop.visible { display: inline-flex; opacity: 1; transform: translateX(-50%) translateY(0); }
.tts-global-stop:hover { background: rgba(239,68,68,0.1); box-shadow: 0 4px 16px rgba(239,68,68,0.25); }
.tts-global-stop:active { transform: translateX(-50%) translateY(1px); }
.tts-global-stop svg { width: 16px; height: 16px; }

.new-translate-btn {
  height: 36px;
  padding: 0 14px;
  border-radius: var(--r16);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--sea);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
}
.new-translate-btn:hover {
  background: var(--seaSoft);
  border-color: var(--sea);
}

/* ===== PHOTO PANEL ===== */
.photo-zone {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--r20);
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.photo-zone:hover {
  border-color: var(--terracotta);
  background: var(--surfaceAlt);
}
.photo-zone svg { width: 40px; height: 40px; color: var(--muted); }
.photo-zone .photo-title { font-size: 15px; font-weight: 500; color: var(--text); }
.photo-zone .photo-sub { font-size: 12px; color: var(--muted); }

.photo-preview {
  display: none;
  border-radius: var(--r20);
  overflow: hidden;
  border: 1px solid var(--border);
  position: relative;
  box-shadow: var(--shadowMd);
}
.photo-preview.visible { display: block; }
.photo-preview img { width: 100%; max-height: 250px; object-fit: cover; display: block; }
.photo-preview .photo-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 12px;
  background: linear-gradient(transparent, rgba(0,0,0,0.5));
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* ===== VOICE PANEL ===== */
.voice-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px 0;
  flex: 1;
  justify-content: center;
}
.mic-ring {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--surface);
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  box-shadow: var(--shadowMd);
}
.mic-ring::before {
  content: '';
  position: absolute;
  inset: -8px;
  border-radius: 50%;
  border: 1px solid transparent;
  transition: all 0.3s;
}
.mic-ring:hover { border-color: var(--terracotta); }
.mic-ring:hover::before { border-color: var(--focus); }
.mic-ring.recording {
  border-color: var(--danger);
  background: rgba(239,68,68,0.08);
  animation: pulse 1.5s ease infinite;
}
.mic-ring.recording::before { border-color: rgba(239,68,68,0.15); }

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.3); }
  50% { box-shadow: 0 0 0 16px rgba(239,68,68,0); }
}

.mic-ring svg { width: 36px; height: 36px; color: var(--muted); transition: color 0.3s; }
.mic-ring.recording svg { color: var(--danger); }

.voice-status { font-size: 14px; color: var(--muted); text-align: center; }
.voice-status.active { color: var(--danger); font-weight: 500; }
.voice-lang-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  color: var(--muted);
  cursor: pointer;
  padding: 4px 10px;
  border-radius: var(--r8);
  border: 1px solid var(--border);
  background: var(--bg);
  transition: all 0.2s;
  user-select: none;
}
.voice-lang-indicator:hover { border-color: var(--terracotta); color: var(--terracotta); }

.voice-transcript {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 20px;
  font-size: 15px;
  line-height: 1.5;
  display: none;
  min-height: 60px;
  color: var(--text);
  box-shadow: var(--shadowMd);
}
.voice-transcript.visible { display: block; }

/* ===== DIALOG PANEL ===== */
.dialog-area {
  display: flex;
  flex-direction: column;
  flex: 1;
  gap: 12px;
}
.dialog-messages {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 200px;
  max-height: calc(100dvh - 380px);
  padding: 4px;
}
.msg-bubble {
  max-width: 85%;
  padding: 12px 16px;
  border-radius: var(--r16);
  font-size: 14px;
  line-height: 1.5;
  animation: slideUp 0.25s ease;
  position: relative;
  box-shadow: var(--shadowSm);
}
.msg-source {
  align-self: flex-start;
  background: var(--surfaceAlt);
  border: 1px solid rgba(242,106,61,0.15);
  border-bottom-left-radius: 4px;
}
.msg-target {
  align-self: flex-end;
  background: var(--seaSoft);
  border: 1px solid rgba(28,140,122,0.15);
  border-bottom-right-radius: 4px;
}
.msg-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  margin-bottom: 4px;
}
.msg-source .msg-label { color: var(--terracotta); }
.msg-target .msg-label { color: var(--sea); }
.msg-text { color: var(--text); }
.msg-gender-badge {
  display: inline-block;
  font-size: 12px;
  margin-left: 3px;
  vertical-align: middle;
  opacity: 0.8;
}
.msg-gender-badge.male { color: var(--sea); }
.msg-gender-badge.female { color: var(--terracotta); }

.msg-play {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: none;
  background: rgba(31,41,55,0.06);
  color: var(--muted);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}
.msg-play:hover { background: var(--seaSoft); color: var(--sea); }
.msg-play svg { width: 14px; height: 14px; }

.dialog-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  box-shadow: var(--shadowMd);
}
.dialog-mic {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  border: 2px solid var(--border);
  background: var(--bg);
  color: var(--muted);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.3s;
}
.dialog-mic:hover { border-color: var(--terracotta); color: var(--terracotta); }
.dialog-mic.recording {
  border-color: var(--danger);
  background: rgba(239,68,68,0.08);
  color: var(--danger);
  animation: pulse 1.5s ease infinite;
}
.dialog-mic svg { width: 22px; height: 22px; }
.dialog-lang-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: var(--muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: var(--r8);
  border: 1px solid var(--border);
  background: var(--bg);
  transition: all 0.2s;
  white-space: nowrap;
  user-select: none;
}
.dialog-lang-indicator:hover { border-color: var(--terracotta); color: var(--terracotta); }

.dialog-input {
  flex: 1;
  padding: 12px;
  border-radius: var(--r12);
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  font-family: var(--font);
  font-size: 14px;
  outline: none;
}
.dialog-input::placeholder { color: var(--muted); }
.dialog-input:focus { border-color: var(--terracotta); box-shadow: 0 0 0 3px var(--focus); }

.dialog-send {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: none;
  background: var(--cta);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 150ms ease;
  box-shadow: var(--ctaShadow);
}
.dialog-send:hover { filter: brightness(1.05); box-shadow: 0 6px 16px rgba(242,106,61,0.30); }
.dialog-send:active { transform: translateY(1px); box-shadow: 0 2px 6px rgba(242,106,61,0.20); }
.dialog-send svg { width: 18px; height: 18px; }

/* ===== AUTO-SPEAK TOGGLE ===== */
.auto-speak { display: flex; align-items: center; gap: 10px; padding: 8px 0; }
.auto-speak label { font-size: 13px; color: var(--muted); cursor: pointer; }
.toggle {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: var(--border);
  position: relative;
  cursor: pointer;
  transition: background 0.3s;
  border: none;
}
.toggle.on { background: var(--sea); }
.toggle::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: white;
  transition: transform 0.3s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}
.toggle.on::after { transform: translateX(18px); }

/* ===== LOADING DOTS ===== */
.loading-dots { display: inline-flex; gap: 4px; align-items: center; }
.loading-dots span {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--muted);
  animation: bounce 1.2s infinite;
}
.loading-dots span:nth-child(2) { animation-delay: 0.15s; }
.loading-dots span:nth-child(3) { animation-delay: 0.3s; }
@keyframes bounce {
  0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }
  40% { transform: scale(1); opacity: 1; }
}

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r12);
  padding: 10px 20px;
  font-size: 13px;
  color: var(--text);
  box-shadow: var(--shadowMd);
  opacity: 0;
  transition: all 0.3s;
  z-index: 200;
  pointer-events: none;
}
.toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

/* ===== STOP BUTTON ===== */
.stop-btn {
  height: 44px;
  padding: 0 18px;
  border-radius: var(--r16);
  border: 2px solid var(--danger);
  background: rgba(239,68,68,0.08);
  color: var(--danger);
  font-family: var(--font);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 150ms ease;
  display: none;
  align-items: center;
  gap: 6px;
}
.stop-btn.visible { display: inline-flex; }
.stop-btn:hover {
  background: rgba(239,68,68,0.15);
  box-shadow: 0 2px 8px rgba(239,68,68,0.2);
}
.stop-btn:active { transform: translateY(1px); }
.stop-btn svg { width: 16px; height: 16px; }

/* ===== FILE UPLOAD PANEL ===== */
.file-zone {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--r20);
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.file-zone:hover {
  border-color: var(--sea);
  background: var(--surfaceAlt);
}
.file-zone.dragover {
  border-color: var(--terracotta);
  background: rgba(242,106,61,0.06);
}
.file-zone svg { width: 40px; height: 40px; color: var(--muted); }
.file-zone .file-title { font-size: 15px; font-weight: 500; color: var(--text); }
.file-zone .file-sub { font-size: 12px; color: var(--muted); }
.file-zone .file-formats { font-size: 11px; color: var(--muted); margin-top: 4px; }

.file-info {
  display: none;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--r20);
  padding: 16px 20px;
  box-shadow: var(--shadowMd);
  gap: 12px;
  flex-direction: column;
}
.file-info.visible { display: flex; }
.file-info-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.file-info-name {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
}
.file-info-name svg { width: 18px; height: 18px; color: var(--sea); flex-shrink: 0; }
.file-info-size {
  font-size: 11px;
  color: var(--muted);
}
.file-info-actions {
  display: flex;
  gap: 8px;
}
.file-content-preview {
  display: none;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: var(--r12);
  padding: 12px 16px;
  font-size: 13px;
  line-height: 1.5;
  color: var(--muted);
  max-height: 150px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
.file-content-preview.visible { display: block; }

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(31,41,55,0.12); border-radius: 2px; }

/* ===== LOGIN SCREEN ===== */
.login-screen { position:fixed;inset:0;background:var(--bg);z-index:1000;display:flex;align-items:center;justify-content:center;padding:20px; }
.login-screen.hidden { display:none; }
.login-card { max-width:380px;width:100%;text-align:center;display:flex;flex-direction:column;align-items:center;gap:16px; }
.login-logo { width:80px;height:80px;border-radius:20px; }
.login-title { font-size:28px;font-weight:600;color:var(--sea); }
.login-title span { color:var(--terracotta); }
.login-subtitle { font-size:14px;color:var(--muted);margin-bottom:8px; }
.login-form { width:100%;display:flex;flex-direction:column;gap:12px; }
.login-input { width:100%;padding:14px 18px;border-radius:var(--r16);border:1px solid var(--border);background:var(--surface);color:var(--text);font-family:var(--font);font-size:15px;outline:none;transition:border-color 0.2s,box-shadow 0.2s; }
.login-input:focus { border-color:rgba(242,106,61,0.25);box-shadow:0 0 0 3px var(--focus); }
.login-input::placeholder { color:var(--muted); }
.login-btn { width:100%;padding:14px;border-radius:var(--r16);border:none;background:var(--cta);color:#fff;font-family:var(--font);font-size:16px;font-weight:600;cursor:pointer;box-shadow:var(--ctaShadow);transition:all 150ms ease; }
.login-btn:hover { filter:brightness(1.05); }
.login-btn:disabled { opacity:0.5;cursor:not-allowed; }
.login-error { font-size:13px;color:var(--danger);min-height:20px; }
.login-tabs { display:flex;gap:0;width:100%;background:var(--surface);border-radius:var(--r16);border:1px solid var(--border);overflow:hidden;margin-bottom:4px; }
.login-tab { flex:1;padding:10px 4px;border:none;background:transparent;color:var(--muted);font-family:var(--font);font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s; }
.login-tab.active { background:var(--seaSoft);color:var(--sea);font-weight:600; }
.login-admin-link { font-size:13px;color:var(--muted);cursor:pointer;transition:color 0.2s;text-decoration:none; }
.login-admin-link:hover { color:var(--sea); }
.login-code-input-wrap { position:relative;width:100%; }
.login-toggle-vis { position:absolute;right:14px;top:50%;transform:translateY(-50%);border:none;background:none;cursor:pointer;color:var(--muted);padding:4px;display:flex;align-items:center; }
.login-toggle-vis:hover { color:var(--text); }

/* ===== HEADER USER MENU ===== */
.header-icon-btn { border:none;background:none;cursor:pointer;color:var(--muted);padding:8px;border-radius:var(--r12);min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center;transition:all 0.2s; }
.header-icon-btn:hover { background:var(--surfaceAlt);color:var(--text); }
.user-menu { display:flex;align-items:center;gap:4px; }

/* ===== HISTORY VIEW ===== */
.history-view { display:none;flex-direction:column;flex:1;min-height:0;position:relative; }
.history-view.visible { display:flex; }
.history-topbar { display:flex;align-items:center;gap:12px;padding:0 0;min-height:56px;border-bottom:1px solid var(--border);flex-shrink:0; }
.history-back { border:none;background:none;cursor:pointer;color:var(--text);padding:8px;margin:-8px 0;display:flex;align-items:center;justify-content:center;border-radius:var(--r12);min-width:40px;min-height:40px; }
.history-back:active { background:var(--surfaceAlt); }
.history-topbar-title { flex:1;font-size:17px;font-weight:600;color:var(--text); }
.history-filter-btn { border:none;background:var(--surfaceAlt);cursor:pointer;color:var(--muted);padding:6px 12px;border-radius:20px;font-family:var(--font);font-size:13px;font-weight:500;display:flex;align-items:center;gap:6px;transition:all 0.15s; }
.history-filter-btn:active { background:var(--seaSoft); }
.history-filter-btn.active-filter { background:var(--seaSoft);color:var(--sea); }
.history-filter-btn svg { width:16px;height:16px;flex-shrink:0; }

/* Filter dropdown */
.history-filter-backdrop { position:absolute;inset:0;z-index:10;display:none; }
.history-filter-backdrop.visible { display:block; }
.history-filter-menu { position:absolute;top:52px;right:0;background:var(--surface);border:1px solid var(--border);border-radius:var(--r16);box-shadow:0 8px 32px rgba(31,41,55,0.12);padding:6px;min-width:180px;z-index:11;opacity:0;transform:translateY(-8px) scale(0.96);transition:all 0.18s ease;pointer-events:none; }
.history-filter-menu.visible { opacity:1;transform:translateY(0) scale(1);pointer-events:auto; }
.history-filter-option { display:flex;align-items:center;gap:10px;width:100%;padding:11px 14px;border:none;background:none;cursor:pointer;font-family:var(--font);font-size:14px;color:var(--text);border-radius:var(--r12);transition:background 0.12s; }
.history-filter-option:active { background:var(--surfaceAlt); }
.history-filter-option.selected { background:var(--seaSoft);color:var(--sea);font-weight:600; }
.history-filter-option svg { width:18px;height:18px;flex-shrink:0;color:var(--muted); }
.history-filter-option.selected svg { color:var(--sea); }

/* List */
.history-list { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:12px 0 20px;display:flex;flex-direction:column;gap:10px; }
.history-item { background:var(--surface);border:1px solid var(--border);border-radius:var(--r16);padding:14px;box-shadow:var(--shadowSm); }
.history-item-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:8px; }
.history-item-mode { font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sea);background:var(--seaSoft);padding:2px 8px;border-radius:6px; }
.history-item-date { font-size:11px;color:var(--muted); }
.history-item-source { font-size:13px;color:var(--muted);margin-bottom:4px;line-height:1.4; }
.history-item-text { font-size:14px;color:var(--text);line-height:1.5; }
.history-item-langs { font-size:11px;color:var(--muted);margin-top:6px; }
.history-dialog-msg { padding:6px 0;border-bottom:1px solid var(--border); }
.history-dialog-msg:last-child { border-bottom:none; }
.history-load-more { margin:0 0 20px;padding:12px;border:1px solid var(--border);border-radius:var(--r16);background:var(--surface);color:var(--sea);font-family:var(--font);font-size:14px;font-weight:500;cursor:pointer;flex-shrink:0; }
.history-load-more.hidden { display:none; }
.history-load-more:active { background:var(--surfaceAlt); }
.history-empty { text-align:center;padding:60px 20px;color:var(--muted); }
.history-empty svg { margin-bottom:12px;color:var(--border); }
.history-empty-text { font-size:15px;font-weight:500;margin-bottom:4px;color:var(--text); }
.history-empty-sub { font-size:13px; }

/* ===== OFFLINE BANNER ===== */
.offline-banner {
  display: none;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 10px 16px;
  background: linear-gradient(90deg, #F59E0B 0%, #F97316 100%);
  color: #fff;
  font-size: 13px;
  font-weight: 600;
  text-align: center;
  border-radius: var(--r12);
  margin-bottom: 12px;
  box-shadow: 0 2px 8px rgba(245,158,11,0.3);
  animation: slideUp 0.3s ease;
}
.offline-banner.visible { display: flex; }
.offline-banner svg { width: 16px; height: 16px; flex-shrink: 0; }

/* ===== PHRASEBOOK ===== */
.phrasebook-view { display:none;flex-direction:column;flex:1;min-height:0; }
.phrasebook-view.visible { display:flex; }
.phrasebook-topbar { display:flex;align-items:center;gap:12px;padding:0;min-height:56px;border-bottom:1px solid var(--border);flex-shrink:0; }
.phrasebook-back { border:none;background:none;cursor:pointer;color:var(--text);padding:8px;margin:-8px 0;display:flex;align-items:center;justify-content:center;border-radius:var(--r12);min-width:40px;min-height:40px; }
.phrasebook-back:active { background:var(--surfaceAlt); }
.phrasebook-topbar-title { flex:1;font-size:17px;font-weight:600;color:var(--text); }

/* Category selector dropdown */
.pb-category-selector { position:relative;padding:12px 0; }
.pb-category-selector-btn { display:flex;align-items:center;gap:8px;padding:10px 16px;border-radius:var(--r12);border:1px solid var(--border);background:var(--surface);color:var(--text);font-family:var(--font);font-size:14px;font-weight:600;cursor:pointer;transition:all 0.15s;width:100%;justify-content:space-between; }
.pb-category-selector-btn:hover { border-color:var(--sea);background:var(--seaSoft); }
.pb-category-selector-btn svg { width:16px;height:16px;color:var(--muted);flex-shrink:0;transition:transform 0.2s; }
.pb-main-category-popup { display:none;position:absolute;top:100%;left:0;right:0;margin-top:2px;background:var(--surface);border:1px solid var(--border);border-radius:var(--r12);padding:4px;box-shadow:var(--shadowLg);z-index:50;max-height:320px;overflow-y:auto; }
.pb-main-category-popup.visible { display:block; }
.pb-main-category-option { display:flex;align-items:center;gap:10px;padding:10px 14px;border-radius:var(--r8);border:none;background:none;color:var(--text);font-family:var(--font);font-size:14px;cursor:pointer;width:100%;text-align:left;transition:background 0.1s; }
.pb-main-category-option:hover { background:var(--surfaceAlt); }
.pb-main-category-option.active { background:var(--seaSoft);color:var(--sea);font-weight:600; }

.phrasebook-list { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:8px 0 20px;display:flex;flex-direction:column;gap:8px; }
.phrasebook-item { background:var(--surface);border:1px solid var(--border);border-radius:var(--r16);padding:14px;box-shadow:var(--shadowSm);cursor:pointer;transition:all 0.15s; }
.phrasebook-item:active { background:var(--surfaceAlt); }
.phrasebook-item-source { font-size:14px;color:var(--text);margin-bottom:4px;line-height:1.4; }
.phrasebook-item-target { font-size:14px;color:var(--sea);line-height:1.4;font-weight:500; }
.phrasebook-item-actions { display:flex;gap:8px;margin-top:8px; }
.phrasebook-item-actions .icon-btn { width:36px;height:36px;border-radius:var(--r12); }
.phrasebook-item-actions .icon-btn svg { width:14px;height:14px; }

/* Phrasebook button in header */
.phrasebook-header-btn { border:none;background:none;cursor:pointer;color:var(--muted);padding:8px;border-radius:var(--r12);min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center;transition:all 0.2s; }
.phrasebook-header-btn:hover { background:var(--surfaceAlt);color:var(--text); }

/* Phrasebook lang bar */
.phrasebook-lang-bar { display:flex;align-items:center;margin:12px 0 0;background:var(--surface);border:1px solid var(--border);border-radius:var(--r20);padding:8px;box-shadow:var(--shadowMd);position:relative; }
.phrasebook-lang-bar::before { content:'';position:absolute;top:20%;bottom:20%;left:50%;width:0;border-left:2px dotted rgba(31,41,55,0.10);pointer-events:none;z-index:0; }
.pb-lang-wrap { flex:1;position:relative;display:flex;align-items:center;justify-content:center; }
.pb-lang-flag { display:flex;align-items:center;padding:10px 6px 10px 10px;pointer-events:none;flex-shrink:0;line-height:0; }
.pb-lang-label { pointer-events:none;font-family:var(--font);font-size:13px;font-weight:500;white-space:nowrap; }
.pb-lang-wrap.source .pb-lang-label { color:var(--terracotta); }
.pb-lang-wrap.target .pb-lang-label { color:var(--sea); }
.pb-lang-select { position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;border:none;background:transparent; }
.pb-lang-select option { background:var(--surface);color:var(--text); }
.pb-lang-swap { width:38px;height:38px;border-radius:50%;border:1px solid var(--border);background:var(--surfaceAlt);color:var(--sea);display:flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0;transition:all 0.3s;z-index:1; }
.pb-lang-swap:hover { color:var(--terracotta);border-color:var(--terracotta);transform:rotate(180deg); }

/* Custom phrases section */
.pb-custom-section { padding:0 0 12px; }
.pb-custom-header { display:flex;align-items:center;justify-content:space-between;padding:8px 0; }
.pb-custom-title { font-size:14px;font-weight:600;color:var(--text);display:flex;align-items:center;gap:6px; }
.pb-custom-count { font-size:11px;color:var(--muted);background:var(--surfaceAlt);padding:2px 8px;border-radius:8px;font-variant-numeric:tabular-nums; }

.pb-add-btn { display:flex;align-items:center;gap:6px;padding:8px 14px;border-radius:var(--r12);border:1px dashed var(--border);background:var(--surface);color:var(--sea);font-family:var(--font);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.15s;width:100%; }
.pb-add-btn:hover { border-color:var(--sea);background:var(--seaSoft); }
.pb-add-btn svg { width:16px;height:16px;flex-shrink:0; }

/* Add phrase form */
.pb-add-form { display:none;background:var(--surface);border:1px solid var(--border);border-radius:var(--r16);padding:16px;margin-bottom:8px;box-shadow:var(--shadowMd);animation:slideUp 0.2s ease; }
.pb-add-form.visible { display:flex;flex-direction:column;gap:12px; }
.pb-add-form-title { font-size:14px;font-weight:600;color:var(--text); }
.pb-add-input { width:100%;padding:10px 14px;border-radius:var(--r12);border:1px solid var(--border);background:var(--bg);color:var(--text);font-family:var(--font);font-size:14px;outline:none;transition:border-color 0.2s,box-shadow 0.2s; }
.pb-add-input:focus { border-color:rgba(242,106,61,0.25);box-shadow:0 0 0 3px var(--focus); }
.pb-add-input::placeholder { color:var(--muted); }
.pb-add-form-actions { display:flex;gap:8px; }
.pb-add-form-actions .btn { min-height:40px; }

/* Custom phrase item delete button */
.pb-item-delete { width:36px;height:36px;border-radius:var(--r12);border:1px solid var(--border);background:var(--surface);color:var(--muted);display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.2s; }
.pb-item-delete:hover { color:var(--danger);border-color:var(--danger);background:rgba(239,68,68,0.06); }
.pb-item-delete svg { width:14px;height:14px; }
.pb-custom-badge { font-size:10px;color:var(--terracotta);background:rgba(242,106,61,0.1);padding:1px 6px;border-radius:6px;font-weight:600; }

/* Auto-translate hint in add form */
.pb-add-translate-wrap { position:relative; }
.pb-add-translate-hint { font-size:11px;color:var(--muted);margin-top:2px;min-height:14px;padding-left:2px; }

/* Category selector in add form */
.pb-add-category-row { display:flex;align-items:center;gap:8px;position:relative; }
.pb-add-category-label { font-size:12px;color:var(--muted);white-space:nowrap; }
.pb-add-category-btn { display:flex;align-items:center;gap:4px;padding:6px 12px;border-radius:var(--r12);border:1px solid var(--border);background:var(--bg);color:var(--text);font-family:var(--font);font-size:13px;cursor:pointer;transition:all 0.15s; }
.pb-add-category-btn:hover { border-color:var(--sea);background:var(--seaSoft); }
.pb-add-category-btn svg { width:12px;height:12px;color:var(--muted);transition:transform 0.2s; }
.pb-add-category-popup { display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:var(--surface);border:1px solid var(--border);border-radius:var(--r12);padding:4px;box-shadow:var(--shadowLg);z-index:50;max-height:240px;overflow-y:auto; }
.pb-add-category-popup.visible { display:block; }
.pb-add-category-option { display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:var(--r8);border:none;background:none;color:var(--text);font-family:var(--font);font-size:13px;cursor:pointer;width:100%;text-align:left;transition:background 0.1s; }
.pb-add-category-option:hover { background:var(--surfaceAlt); }
.pb-add-category-option.active { background:var(--seaSoft);color:var(--sea);font-weight:500; }

/* Save to phrasebook button states */
.icon-btn.saved { color:var(--success);border-color:var(--success); }
.icon-btn.saved:hover { background:rgba(16,185,129,0.08); }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
</head>
<body>

<!-- LOGIN SCREEN -->
<div class="login-screen" id="loginScreen">
  <div class="login-card">
    <img class="login-logo" src="icons/icon.svg" alt="TravelTalk">
    <div class="login-title">Travel<span>Talk</span></div>
    <div class="login-subtitle">Мультиязычный переводчик для путешествий</div>
    <div class="login-tabs">
      <button class="login-tab active" onclick="switchLoginTab('code')">Вход по коду</button>
      <button class="login-tab" onclick="switchLoginTab('admin')">Администратор</button>
    </div>
    <!-- Code login form -->
    <form class="login-form" id="loginFormCode" onsubmit="handleLogin(event)">
      <div class="login-code-input-wrap">
        <input class="login-input" id="inviteCodeInput" type="password" placeholder="Код приглашения" autocomplete="off" style="text-transform:uppercase;padding-right:48px" required>
        <button type="button" class="login-toggle-vis" onclick="toggleCodeVisibility()" title="Показать код">
          <svg id="codeVisIcon" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
      </div>
      <button class="login-btn" type="submit" id="loginBtn">Войти</button>
      <div class="login-error" id="loginError"></div>
    </form>
    <!-- Admin login form -->
    <form class="login-form" id="loginFormAdmin" style="display:none" onsubmit="handleAdminLogin(event)">
      <div class="login-code-input-wrap">
        <input class="login-input" id="adminPasswordInput" type="password" placeholder="Пароль администратора" autocomplete="off" style="padding-right:48px" required>
        <button type="button" class="login-toggle-vis" onclick="toggleAdminPassVisibility()" title="Показать пароль">
          <svg id="adminVisIcon" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
      </div>
      <button class="login-btn" type="submit" id="adminLoginBtn">Войти как администратор</button>
      <div class="login-error" id="adminLoginError"></div>
    </form>
  </div>
</div>

<div class="app" style="display:none">
  <div id="mainView" style="display:flex;flex-direction:column;flex:1;min-height:0">
  <div class="header">
    <div class="logo">
      <img class="logo-icon" src="icons/icon.svg" alt="T">
      <div class="logo-text">Travel<span>Talk</span></div>
    </div>
    <div style="display:flex;align-items:center;gap:4px">
      <button class="voice-gender-btn" id="voiceGenderBtn" onclick="toggleVoiceGender()" title="Сменить голос">
        <svg id="voiceGenderIcon" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>
        <span id="voiceGenderLabel">Жен</span>
      </button>
      <button class="phrasebook-header-btn" onclick="togglePhrasebook()" title="Разговорник">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="8" y1="7" x2="16" y2="7"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
      </button>
      <button class="icon-btn header-icon-btn" onclick="toggleHistory()" title="История">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
      </button>
      <div class="user-menu" id="userMenu" style="display:none">
        <button class="icon-btn header-icon-btn" onclick="logout()" title="Выйти">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
        </button>
      </div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="text">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
      Текст
    </button>
    <button class="tab" data-tab="photo">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
      Фото
    </button>
    <button class="tab" data-tab="voice">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
      Голос
    </button>
    <button class="tab" data-tab="dialog">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
      Диалог
    </button>
    <button class="tab" data-tab="file">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
      Файл
    </button>
  </div>

  <div class="offline-banner" id="offlineBanner">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/><path d="M10.71 5.05A16 16 0 0 1 22.56 9"/><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>
    Оффлайн — доступен разговорник и кэш
  </div>

  <div class="lang-bar">
    <div class="lang-select-wrap source">
      <span class="lang-flag" id="langFromFlag"></span>
      <span class="lang-label" id="langFromLabel"></span>
      <select class="lang-select" id="langFrom" onchange="updateLangs()">
        <option value="ru">Русский</option>
        <option value="pt-BR">Português</option>
        <option value="en">English</option>
        <option value="de">Deutsch</option>
        <option value="fr">Français</option>
        <option value="it">Italiano</option>
        <option value="es">Español</option>
        <option value="el">Ελληνικά</option>
      </select>
    </div>
    <button class="lang-swap" onclick="swapLangs()">
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
    </button>
    <div class="lang-select-wrap target">
      <span class="lang-flag" id="langToFlag"></span>
      <span class="lang-label" id="langToLabel"></span>
      <select class="lang-select" id="langTo" onchange="updateLangs()">
        <option value="en">English</option>
        <option value="pt-BR">Português</option>
        <option value="ru">Русский</option>
        <option value="de">Deutsch</option>
        <option value="fr">Français</option>
        <option value="it">Italiano</option>
        <option value="es">Español</option>
        <option value="el">Ελληνικά</option>
      </select>
    </div>
  </div>

  <div class="content">

    <!-- TEXT -->
    <div class="panel active" id="panel-text">
      <div class="text-area-wrap">
        <textarea id="textInput" placeholder="Введите текст для перевода..." oninput="updateCharCount()"></textarea>
        <div class="text-actions">
          <span class="char-count" id="charCount">0</span>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="stop-btn" id="textStopBtn" onclick="stopCurrentOperation()">
              <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              Стоп
            </button>
            <button class="translate-btn" id="textTranslateBtn" onclick="translateText()">Перевести</button>
          </div>
        </div>
      </div>
      <div class="result-card" id="textResult">
        <div class="result-label" id="textResultLabel">Перевод</div>
        <div class="result-text" id="textResultText"></div>
        <div class="result-examples" id="textExamples">
          <div class="result-examples-title">Примеры использования</div>
          <div id="textExamplesList"></div>
        </div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('textResultText')" title="Копировать">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('textResultText', this)" title="Озвучить">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
          </button>
          <button class="icon-btn" onclick="saveResultToPhrasebook('text')" title="В разговорник" id="textSavePhraseBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="12" y1="8" x2="12" y2="14"/><line x1="9" y1="11" x2="15" y2="11"/></svg>
          </button>
          <div style="flex:1"></div>
          <button class="new-translate-btn" onclick="clearTextForm()" title="Новый перевод">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            Новый перевод
          </button>
        </div>
      </div>
    </div>

    <!-- PHOTO -->
    <div class="panel" id="panel-photo">
      <div class="photo-zone" onclick="document.getElementById('photoInput').click()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
        <div class="photo-title">Сфотографировать или выбрать</div>
        <div class="photo-sub">Вывеска, меню, документ</div>
      </div>
      <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none" onchange="handlePhoto(event)">
      <div class="photo-preview" id="photoPreview">
        <img id="photoImg" src="" alt="">
        <div class="photo-overlay">
          <button class="btn btn-primary" id="photoTranslateBtn" style="flex:none;padding:8px 16px;font-size:12px" onclick="translatePhoto()">Распознать и перевести</button>
          <button class="stop-btn" id="photoStopBtn" onclick="stopCurrentOperation()" style="height:36px;padding:0 12px;font-size:12px">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
            Стоп
          </button>
          <button class="icon-btn" onclick="clearPhoto()" style="background:rgba(0,0,0,0.5);border:none">
            <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
      </div>
      <div class="result-card" id="photoOcrResult">
        <div class="result-label">Распознанный текст</div>
        <div class="result-text" id="photoOcrText"></div>
      </div>
      <div class="result-card" id="photoTransResult">
        <div class="result-label">Перевод</div>
        <div class="result-text" id="photoTransText"></div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('photoTransText')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('photoTransText', this)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- VOICE -->
    <div class="panel" id="panel-voice">
      <div class="voice-area">
        <div class="mic-ring" id="voiceMic" onclick="toggleVoiceRecording()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
        </div>
        <span class="voice-lang-indicator" id="voiceLangIndicator" onclick="toggleVoiceLang()" title="Нажмите, чтобы переключить язык записи"></span>
        <div class="voice-status" id="voiceStatus">Нажмите для записи</div>
        <div class="voice-transcript" id="voiceTranscript"></div>
        <div class="result-card" id="voiceResult">
          <div class="result-label">Перевод</div>
          <div class="result-text" id="voiceResultText"></div>
          <div class="result-examples" id="voiceExamples">
            <div class="result-examples-title">Примеры использования</div>
            <div id="voiceExamplesList"></div>
          </div>
          <div class="result-actions">
            <button class="icon-btn" onclick="copyResult('voiceResultText')">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
            </button>
            <button class="icon-btn" onclick="speakResult('voiceResultText', this)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
            </button>
            <button class="icon-btn" onclick="saveResultToPhrasebook('voice')" title="В разговорник" id="voiceSavePhraseBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="12" y1="8" x2="12" y2="14"/><line x1="9" y1="11" x2="15" y2="11"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- FILE -->
    <div class="panel" id="panel-file">
      <div class="file-zone" id="fileZone" onclick="document.getElementById('fileInput').click()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
        <div class="file-title">Загрузить файл для перевода</div>
        <div class="file-sub">Перетащите файл сюда или нажмите</div>
        <div class="file-formats">.pdf, .docx, изображения, .txt, .html, .csv, .json, .md, .xml</div>
      </div>
      <input type="file" id="fileInput" accept=".txt,.text,.html,.htm,.csv,.json,.md,.markdown,.xml,.srt,.sub,.vtt,.log,.ini,.cfg,.yaml,.yml,.tsv,.pdf,.docx,.jpg,.jpeg,.png,.gif,.webp,.bmp,.tiff,.tif,.heic,.heif,.avif,.svg,image/*" style="display:none" onchange="handleFileUpload(event)">
      <div class="file-info" id="fileInfo">
        <div class="file-info-header">
          <div class="file-info-name">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
            <span id="fileName"></span>
          </div>
          <span class="file-info-size" id="fileSize"></span>
        </div>
        <div class="file-content-preview visible" id="filePreview"></div>
        <img id="fileImagePreview" src="" alt="" style="display:none;width:100%;max-height:200px;object-fit:contain;border-radius:var(--r12);border:1px solid var(--border)">
        <div class="file-info-actions">
          <button class="btn btn-primary" id="fileTranslateBtn" onclick="translateFile()" style="flex:1">Перевести файл</button>
          <button class="stop-btn" id="fileStopBtn" onclick="stopCurrentOperation()">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
            Стоп
          </button>
          <button class="btn btn-ghost" onclick="clearFile()" style="flex:none;padding:8px 16px">Убрать</button>
        </div>
      </div>
      <div class="result-card" id="fileResult">
        <div class="result-label" id="fileResultLabel">Перевод файла</div>
        <div class="result-text" id="fileResultText" style="white-space:pre-wrap"></div>
        <div class="result-actions">
          <button class="icon-btn" onclick="copyResult('fileResultText')" title="Копировать">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          </button>
          <button class="icon-btn" onclick="downloadTranslation()" title="Скачать перевод">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          </button>
          <button class="icon-btn" onclick="speakResult('fileResultText', this)" title="Озвучить">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- DIALOG -->
    <div class="panel" id="panel-dialog">
      <div class="dialog-area">
        <div class="auto-speak">
          <button class="toggle on" id="autoSpeakToggle" onclick="toggleAutoSpeak()"></button>
          <label onclick="toggleAutoSpeak()">Автоозвучка перевода</label>
        </div>
        <div class="dialog-messages" id="dialogMessages">
          <div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">
            Нажмите на микрофон и произнесите фразу.<br>Для озвучки перевода нажмите на микрофон ещё раз.
          </div>
        </div>
        <div class="dialog-controls">
          <span class="dialog-lang-indicator" id="dialogLangIndicator" onclick="toggleDialogLang()" title="Нажмите, чтобы переключить язык записи"></span>
          <button class="dialog-mic" id="dialogMic" onclick="toggleDialogRecording()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
          </button>
          <input class="dialog-input" id="dialogInput" placeholder="Или введите текст..." onkeydown="if(event.key==='Enter')sendDialog()">
          <button class="dialog-send" onclick="sendDialog()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
          </button>
        </div>
      </div>
    </div>

  </div>
  </div><!-- /mainView -->

  <!-- HISTORY VIEW -->
  <div class="history-view" id="historyView">
    <div class="history-topbar">
      <button class="history-back" onclick="toggleHistory()">
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
      </button>
      <div class="history-topbar-title">История</div>
      <button class="history-filter-btn" id="historyFilterBtn" onclick="toggleFilterMenu()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>
        <span id="historyFilterLabel">Все</span>
        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
      </button>
    </div>
    <div class="history-filter-backdrop" id="filterBackdrop" onclick="closeFilterMenu()"></div>
    <div class="history-filter-menu" id="filterMenu">
      <button class="history-filter-option selected" data-filter="all" onclick="selectFilter('all')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
        Все
      </button>
      <button class="history-filter-option" data-filter="text" onclick="selectFilter('text')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
        Текст
      </button>
      <button class="history-filter-option" data-filter="photo" onclick="selectFilter('photo')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
        Фото
      </button>
      <button class="history-filter-option" data-filter="voice" onclick="selectFilter('voice')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
        Голос
      </button>
      <button class="history-filter-option" data-filter="dialog" onclick="selectFilter('dialog')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
        Диалог
      </button>
      <button class="history-filter-option" data-filter="file" onclick="selectFilter('file')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
        Файл
      </button>
    </div>
    <div class="history-list" id="historyList">
      <div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">Загрузка...</div>
    </div>
    <button class="history-load-more hidden" id="historyLoadMore" onclick="loadMoreHistory()">Загрузить ещё</button>
  </div>

  <!-- PHRASEBOOK VIEW -->
  <div class="phrasebook-view" id="phrasebookView">
    <div class="phrasebook-topbar">
      <button class="phrasebook-back" onclick="togglePhrasebook()">
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
      </button>
      <div class="phrasebook-topbar-title">Разговорник</div>
    </div>
    <div class="phrasebook-lang-bar">
      <div class="pb-lang-wrap source">
        <span class="pb-lang-flag" id="pbLangFromFlag"></span>
        <span class="pb-lang-label" id="pbLangFromLabel"></span>
        <select class="pb-lang-select" id="pbLangFrom" onchange="updatePhrasebookLangs()">
          <option value="ru">Русский</option>
          <option value="pt-BR">Português</option>
          <option value="en">English</option>
          <option value="de">Deutsch</option>
          <option value="fr">Français</option>
          <option value="it">Italiano</option>
          <option value="es">Español</option>
          <option value="el">Ελληνικά</option>
        </select>
      </div>
      <button class="pb-lang-swap" onclick="swapPhrasebookLangs()">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
      </button>
      <div class="pb-lang-wrap target">
        <span class="pb-lang-flag" id="pbLangToFlag"></span>
        <span class="pb-lang-label" id="pbLangToLabel"></span>
        <select class="pb-lang-select" id="pbLangTo" onchange="updatePhrasebookLangs()">
          <option value="en">English</option>
          <option value="pt-BR">Português</option>
          <option value="ru">Русский</option>
          <option value="de">Deutsch</option>
          <option value="fr">Français</option>
          <option value="it">Italiano</option>
          <option value="es">Español</option>
          <option value="el">Ελληνικά</option>
        </select>
      </div>
    </div>
    <div class="pb-category-selector">
      <button class="pb-category-selector-btn" id="pbCategorySelectorBtn" type="button" onclick="togglePbMainCategoryPopup()">
        <span id="pbCategorySelectorText">Мои фразы</span>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
      </button>
      <div class="pb-main-category-popup" id="pbMainCategoryPopup"></div>
    </div>

    <!-- Add phrase form (hidden by default) -->
    <div class="pb-add-form" id="pbAddForm">
      <div class="pb-add-form-title">Новая фраза</div>
      <input class="pb-add-input" id="pbAddSource" placeholder="Фраза на исходном языке" oninput="onPbAddSourceInput()">
      <div class="pb-add-translate-wrap">
        <input class="pb-add-input" id="pbAddTarget" placeholder="Перевод" oninput="this.dataset.manualEdit='1'">
        <div class="pb-add-translate-hint" id="pbAddTranslateHint"></div>
      </div>
      <div class="pb-add-category-row">
        <span class="pb-add-category-label">Раздел:</span>
        <button class="pb-add-category-btn" id="pbAddCategoryBtn" type="button" onclick="togglePbCategoryPopup()">
          <span id="pbAddCategoryText">Мои фразы</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
        </button>
        <div class="pb-add-category-popup" id="pbAddCategoryPopup"></div>
      </div>
      <div class="pb-add-form-actions">
        <button class="btn btn-primary" onclick="saveCustomPhrase()" style="flex:1">Сохранить</button>
        <button class="btn btn-ghost" onclick="hideAddPhraseForm()" style="flex:none;padding:8px 16px">Отмена</button>
      </div>
    </div>

    <!-- Custom phrases section -->
    <div class="pb-custom-section" id="pbCustomSection" style="display:none">
      <div class="pb-custom-header">
        <div class="pb-custom-title">Мои фразы <span class="pb-custom-count" id="pbCustomCount">0</span></div>
      </div>
      <div id="pbCustomList"></div>
    </div>

    <button class="pb-add-btn" id="pbAddBtn" onclick="showAddPhraseForm()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
      Добавить свою фразу
    </button>

    <div class="phrasebook-list" id="phrasebookList"></div>
  </div>

</div><!-- /app -->


<div class="toast" id="toast"></div>
<button class="tts-global-stop" id="ttsGlobalStop" onclick="stopAudio()">
  <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
  Стоп
</button>

<script>
// ===== AUTH & SESSION =====
let authToken = localStorage.getItem('traveltalk_token');
let currentUser = null;
let currentDialogSessionId = null;
let dialogMessageSeq = 0;

function getDeviceId() {
  let id = localStorage.getItem('traveltalk_device_id');
  if (!id) { id = crypto.randomUUID(); localStorage.setItem('traveltalk_device_id', id); }
  return id;
}

function getAuthHeaders() {
  return authToken ? { 'Authorization': 'Bearer ' + authToken } : {};
}

async function checkSession() {
  if (!authToken) { showLoginScreen(); return; }
  try {
    const res = await fetch('/api/auth/validate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + authToken }
    });
    const data = await res.json();
    if (data.valid) {
      currentUser = data.user;
      hideLoginScreen();
    } else {
      localStorage.removeItem('traveltalk_token');
      authToken = null;
      showLoginScreen();
    }
  } catch (e) {
    // Network error — allow offline usage if token exists
    hideLoginScreen();
  }
}

function showLoginScreen() {
  document.getElementById('loginScreen').classList.remove('hidden');
  document.querySelector('.app').style.display = 'none';
}

function hideLoginScreen() {
  document.getElementById('loginScreen').classList.add('hidden');
  document.querySelector('.app').style.display = 'flex';
  if (currentUser) {
    document.getElementById('userMenu').style.display = 'flex';
  }
}

function switchLoginTab(tab) {
  const tabs = document.querySelectorAll('.login-tab');
  tabs[0].classList.toggle('active', tab === 'code');
  tabs[1].classList.toggle('active', tab === 'admin');
  document.getElementById('loginFormCode').style.display = tab === 'code' ? 'flex' : 'none';
  document.getElementById('loginFormAdmin').style.display = tab === 'admin' ? 'flex' : 'none';
  document.getElementById('loginError').textContent = '';
  document.getElementById('adminLoginError').textContent = '';
}

function toggleCodeVisibility() {
  const input = document.getElementById('inviteCodeInput');
  const isHidden = input.type === 'password';
  input.type = isHidden ? 'text' : 'password';
  document.getElementById('codeVisIcon').innerHTML = isHidden
    ? '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
    : '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>';
}

function toggleAdminPassVisibility() {
  const input = document.getElementById('adminPasswordInput');
  const isHidden = input.type === 'password';
  input.type = isHidden ? 'text' : 'password';
  document.getElementById('adminVisIcon').innerHTML = isHidden
    ? '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
    : '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>';
}

async function handleLogin(e) {
  e.preventDefault();
  const code = document.getElementById('inviteCodeInput').value.trim();
  const errorEl = document.getElementById('loginError');
  const btn = document.getElementById('loginBtn');
  if (!code) return;

  btn.disabled = true; btn.textContent = 'Проверка...';
  errorEl.textContent = '';

  try {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code: code.toUpperCase(), device_id: getDeviceId() })
    });
    const data = await res.json();
    if (!res.ok) { errorEl.textContent = data.error || 'Ошибка входа'; return; }
    authToken = data.token;
    currentUser = data.user;
    localStorage.setItem('traveltalk_token', data.token);
    hideLoginScreen();
  } catch (e) {
    errorEl.textContent = 'Ошибка сети. Попробуйте ещё раз.';
  } finally {
    btn.disabled = false; btn.textContent = 'Войти';
  }
}

async function handleAdminLogin(e) {
  e.preventDefault();
  const password = document.getElementById('adminPasswordInput').value.trim();
  const errorEl = document.getElementById('adminLoginError');
  const btn = document.getElementById('adminLoginBtn');
  if (!password) return;

  btn.disabled = true; btn.textContent = 'Проверка...';
  errorEl.textContent = '';

  try {
    const res = await fetch('/api/admin/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ password })
    });
    const data = await res.json();
    if (!res.ok) { errorEl.textContent = data.error || 'Ошибка входа'; return; }
    localStorage.setItem('tt_admin_token', data.token);
    window.location.href = '/admin';
  } catch (e) {
    errorEl.textContent = 'Ошибка сети. Попробуйте ещё раз.';
  } finally {
    btn.disabled = false; btn.textContent = 'Войти как администратор';
  }
}

function logout() {
  fetch('/api/auth/logout', { method: 'POST', headers: { 'Authorization': 'Bearer ' + authToken } }).catch(() => {});
  localStorage.removeItem('traveltalk_token');
  authToken = null; currentUser = null;
  document.getElementById('userMenu').style.display = 'none';
  showLoginScreen();
}

// ===== SAVE HELPERS =====
function saveTranslation(mode, srcLang, tgtLang, sourceText, translatedText, metadata) {
  if (!authToken) return;
  fetch('/api/history/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
    body: JSON.stringify({ mode, source_lang: srcLang, target_lang: tgtLang, source_text: sourceText, translated_text: translatedText, metadata: metadata || {} })
  }).catch(() => {});
}

async function startDialogSession() {
  if (!authToken) return;
  dialogMessageSeq = 0;
  try {
    const res = await fetch('/api/history/dialog-start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
      body: JSON.stringify({ source_lang: sourceLang, target_lang: targetLang })
    });
    const data = await res.json();
    if (res.ok) currentDialogSessionId = data.session_id;
  } catch (e) {}
}

function saveDialogMessages(srcLangCode, sourceText, tgtLangCode, translatedText, detectedGender) {
  if (!authToken || !currentDialogSessionId) return;
  dialogMessageSeq += 1;
  const srcSeq = dialogMessageSeq;
  dialogMessageSeq += 1;
  const tgtSeq = dialogMessageSeq;
  fetch('/api/history/dialog-message', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
    body: JSON.stringify({
      dialog_session_id: currentDialogSessionId,
      messages: [
        { lang_code: srcLangCode, role: 'source', text: sourceText, detected_gender: null, seq_order: srcSeq },
        { lang_code: tgtLangCode, role: 'translation', text: translatedText, detected_gender: detectedGender || null, seq_order: tgtSeq }
      ]
    })
  }).catch(() => {});
}

// ===== HISTORY UI =====
let historyPage = 1;
let historyType = 'all';
let historyLoading = false;
const HISTORY_FILTER_NAMES = { all: 'Все', text: 'Текст', photo: 'Фото', voice: 'Голос', dialog: 'Диалог', file: 'Файл' };

function toggleHistory() {
  const main = document.getElementById('mainView');
  const hist = document.getElementById('historyView');
  const isOpen = hist.classList.contains('visible');
  if (isOpen) {
    hist.classList.remove('visible');
    main.style.display = '';
    closeFilterMenu();
  } else {
    main.style.display = 'none';
    hist.classList.add('visible');
    historyPage = 1;
    loadHistory();
  }
}

function toggleFilterMenu() {
  const menu = document.getElementById('filterMenu');
  const backdrop = document.getElementById('filterBackdrop');
  const isOpen = menu.classList.contains('visible');
  if (isOpen) {
    closeFilterMenu();
  } else {
    menu.classList.add('visible');
    backdrop.classList.add('visible');
  }
}

function closeFilterMenu() {
  document.getElementById('filterMenu').classList.remove('visible');
  document.getElementById('filterBackdrop').classList.remove('visible');
}

function selectFilter(type) {
  historyType = type;
  historyPage = 1;

  // Update button label
  document.getElementById('historyFilterLabel').textContent = HISTORY_FILTER_NAMES[type] || 'Все';

  // Update filter button style
  const btn = document.getElementById('historyFilterBtn');
  btn.classList.toggle('active-filter', type !== 'all');

  // Update selected state in menu
  document.querySelectorAll('.history-filter-option').forEach(opt => {
    opt.classList.toggle('selected', opt.dataset.filter === type);
  });

  closeFilterMenu();
  loadHistory();
}

async function loadHistory() {
  if (historyLoading || !authToken) return;
  historyLoading = true;
  const list = document.getElementById('historyList');
  if (historyPage === 1) list.innerHTML = '<div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">Загрузка...</div>';

  try {
    if (historyType === 'dialog') {
      const res = await fetch('/api/history/dialogs?page=' + historyPage + '&limit=20', { headers: getAuthHeaders() });
      const data = await res.json();
      if (historyPage === 1) list.innerHTML = '';
      if (!data.dialogs || data.dialogs.length === 0) {
        if (historyPage === 1) list.innerHTML = renderHistoryEmpty('Диалогов пока нет', 'Начните диалог, и он появится здесь');
        document.getElementById('historyLoadMore').classList.add('hidden');
      } else {
        data.dialogs.forEach(d => {
          const el = document.createElement('div');
          el.className = 'history-item';
          const date = new Date(d.created_at).toLocaleString('ru-RU', { day:'numeric', month:'short', hour:'2-digit', minute:'2-digit' });
          let msgs = '';
          if (d.messages) d.messages.forEach(m => {
            msgs += '<div class="history-dialog-msg"><span style="font-size:11px;color:var(--sea)">' + (m.lang_code || '') + '</span> ' + escapeHtml(m.text) + '</div>';
          });
          el.innerHTML = '<div class="history-item-header"><span class="history-item-mode">Диалог</span><span class="history-item-date">' + date + '</span></div>' + msgs;
          list.appendChild(el);
        });
        document.getElementById('historyLoadMore').classList.toggle('hidden', data.dialogs.length < 20);
      }
    } else {
      const mode = historyType === 'all' ? '' : '&mode=' + historyType;
      const res = await fetch('/api/history/list?page=' + historyPage + '&limit=20' + mode, { headers: getAuthHeaders() });
      const data = await res.json();
      if (historyPage === 1) list.innerHTML = '';
      if (!data.translations || data.translations.length === 0) {
        if (historyPage === 1) list.innerHTML = renderHistoryEmpty('Переводов пока нет', 'Здесь будет история ваших переводов');
        document.getElementById('historyLoadMore').classList.add('hidden');
      } else {
        data.translations.forEach(t => {
          const el = document.createElement('div');
          el.className = 'history-item';
          const date = new Date(t.created_at).toLocaleString('ru-RU', { day:'numeric', month:'short', hour:'2-digit', minute:'2-digit' });
          const modeNames = { text: 'Текст', photo: 'Фото', voice: 'Голос', file: 'Файл' };
          el.innerHTML = '<div class="history-item-header"><span class="history-item-mode">' + (modeNames[t.mode] || t.mode) + '</span><span class="history-item-date">' + date + '</span></div>' +
            '<div class="history-item-source">' + escapeHtml((t.source_text || '').substring(0, 200)) + '</div>' +
            '<div class="history-item-text">' + escapeHtml((t.translated_text || '').substring(0, 300)) + '</div>' +
            '<div class="history-item-langs">' + (t.source_lang || '') + ' → ' + (t.target_lang || '') + '</div>';
          list.appendChild(el);
        });
        document.getElementById('historyLoadMore').classList.toggle('hidden', data.translations.length < 20);
      }
    }
  } catch (e) {
    if (historyPage === 1) list.innerHTML = renderHistoryEmpty('Ошибка загрузки', 'Проверьте подключение к интернету');
  }
  historyLoading = false;
}

function renderHistoryEmpty(title, sub) {
  return '<div class="history-empty"><svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg><div class="history-empty-text">' + title + '</div><div class="history-empty-sub">' + sub + '</div></div>';
}

function loadMoreHistory() {
  historyPage++;
  loadHistory();
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

// ===== LANGUAGE CONFIG =====
const LANGS = {
  'ru':    { name: 'Русский',    flagCode: 'ru', speech: 'ru-RU',  tts: 'ru-RU' },
  'pt-BR': { name: 'Português',  flagCode: 'br', speech: 'pt-BR',  tts: 'pt-BR' },
  'en':    { name: 'English',    flagCode: 'gb', speech: 'en-US',  tts: 'en-US' },
  'de':    { name: 'Deutsch',    flagCode: 'de', speech: 'de-DE',  tts: 'de-DE' },
  'fr':    { name: 'Français',   flagCode: 'fr', speech: 'fr-FR',  tts: 'fr-FR' },
  'it':    { name: 'Italiano',   flagCode: 'it', speech: 'it-IT',  tts: 'it-IT' },
  'es':    { name: 'Español',    flagCode: 'es', speech: 'es-ES',  tts: 'es-ES' },
  'el':    { name: 'Ελληνικά',  flagCode: 'gr', speech: 'el-GR',  tts: 'el-GR' }
};
function flagImg(code, size) {
  size = size || 20;
  return '<img src="https://flagcdn.com/w40/' + code + '.png" width="' + size + '" height="' + Math.round(size * 0.75) + '" alt="" style="vertical-align:middle;border-radius:2px">';
}

const LANG_NAMES_FOR_PROMPT = {
  'ru': 'Russian', 'pt-BR': 'Brazilian Portuguese',
  'en': 'English', 'de': 'German', 'fr': 'French',
  'it': 'Italian', 'es': 'Spanish', 'el': 'Greek'
};

let sourceLang = 'ru';
let targetLang = 'en';
let autoSpeak = true;
let voiceRecording = false;
let dialogRecording = false;
let recognition = null;
let dialogFirstMessage = true;
let dialogNextLang = 'ru';
let voiceNextLang = 'ru';
let voiceGender = localStorage.getItem('traveltalk_voice') || 'female';

function getSourceName() { return LANG_NAMES_FOR_PROMPT[sourceLang]; }
function getTargetName() { return LANG_NAMES_FOR_PROMPT[targetLang]; }

// ===== INIT =====
document.addEventListener('DOMContentLoaded', () => {
  checkSession().then(() => {
    initTabs();
    updateLangs();
    updateVoiceGenderUI();
  });
});

function toggleVoiceGender() {
  voiceGender = voiceGender === 'female' ? 'male' : 'female';
  localStorage.setItem('traveltalk_voice', voiceGender);
  updateVoiceGenderUI();
}

function updateVoiceGenderUI() {
  const btn = document.getElementById('voiceGenderBtn');
  const label = document.getElementById('voiceGenderLabel');
  btn.classList.remove('male', 'female');
  btn.classList.add(voiceGender);
  label.textContent = voiceGender === 'female' ? 'Жен' : 'Муж';
}

function initTabs() {
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
    });
  });
}

// ===== LANGUAGE =====
function updateLangs() {
  sourceLang = document.getElementById('langFrom').value;
  targetLang = document.getElementById('langTo').value;
  if (sourceLang === targetLang) {
    const keys = Object.keys(LANGS);
    const alt = keys.find(k => k !== sourceLang);
    targetLang = alt;
    document.getElementById('langTo').value = alt;
  }
  document.getElementById('langFromFlag').innerHTML = flagImg(LANGS[sourceLang].flagCode);
  document.getElementById('langToFlag').innerHTML = flagImg(LANGS[targetLang].flagCode);
  document.getElementById('langFromLabel').textContent = LANGS[sourceLang].name;
  document.getElementById('langToLabel').textContent = LANGS[targetLang].name;
  dialogNextLang = sourceLang;
  voiceNextLang = sourceLang;
  // Clear dialog history on language change
  dialogFirstMessage = true;
  currentDialogSessionId = null;
  const dialogContainer = document.getElementById('dialogMessages');
  if (dialogContainer) {
    dialogContainer.innerHTML = '<div style="text-align:center;padding:40px 0;color:var(--muted);font-size:13px">Нажмите на микрофон и произнесите фразу.<br>Для озвучки перевода нажмите на микрофон ещё раз.</div>';
  }
  // Clear voice mode results
  const voiceTranscript = document.getElementById('voiceTranscript');
  if (voiceTranscript) { voiceTranscript.textContent = ''; voiceTranscript.classList.remove('visible'); }
  const voiceResult = document.getElementById('voiceResult');
  if (voiceResult) { voiceResult.classList.remove('visible'); }
  renderExamples(null, 'voiceExamples', 'voiceExamplesList');
  updateDialogLangIndicator();
  updateVoiceLangIndicator();
}

function swapLangs() {
  const fromEl = document.getElementById('langFrom');
  const toEl = document.getElementById('langTo');
  const tmp = fromEl.value;
  fromEl.value = toEl.value;
  toEl.value = tmp;
  updateLangs();
}

function updateDialogLangIndicator() {
  const el = document.getElementById('dialogLangIndicator');
  if (!el) return;
  const lang = LANGS[dialogNextLang];
  if (!lang) return;
  el.innerHTML = flagImg(lang.flagCode, 16);
}

function flipDialogLang() {
  dialogNextLang = (dialogNextLang === sourceLang) ? targetLang : sourceLang;
  updateDialogLangIndicator();
}

function toggleDialogLang() {
  flipDialogLang();
}

function updateVoiceLangIndicator() {
  const el = document.getElementById('voiceLangIndicator');
  if (!el) return;
  const lang = LANGS[voiceNextLang];
  if (!lang) return;
  el.innerHTML = flagImg(lang.flagCode, 16) + ' ' + lang.name;
}

function flipVoiceLang() {
  voiceNextLang = (voiceNextLang === sourceLang) ? targetLang : sourceLang;
  updateVoiceLangIndicator();
}

function toggleVoiceLang() {
  flipVoiceLang();
}

// ===== API =====
async function callTranslate(systemPrompt, userContent, maxTokens, signal) {
  const opts = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
    body: JSON.stringify({
      system: systemPrompt,
      content: userContent,
      max_tokens: maxTokens || 1024
    })
  };
  if (signal) opts.signal = signal;

  const res = await fetch('/api/translate', opts);

  if (res.status === 401) { showLoginScreen(); throw new Error('Unauthorized'); }
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'API error: ' + res.status);
  return data.text;
}

function getAutoTranslatePrompt() {
  return 'You are a professional translator. The user has a language pair: ' + getSourceName() + ' and ' + getTargetName() + '. Auto-detect the language of the input text. If it is ' + getSourceName() + ', translate to ' + getTargetName() + '. If it is ' + getTargetName() + ', translate to ' + getSourceName() + '. If it is neither, translate to ' + getTargetName() + '. IMPORTANT: Always provide a proper semantic translation of the meaning. Never transliterate or write words phonetically in another script. For example, German "Flughafen" must be translated to Russian "аэропорт", not transliterated as "Флюгхафен". CRITICAL: Translate the COMPLETE input text including ALL sentences as a single unit. Never skip, omit, or drop any sentence. Every sentence in the input must appear translated in the output. Reply ONLY with this JSON: {"from":"LANG_CODE","text":"TRANSLATED_TEXT"} where LANG_CODE is one of: ' + Object.keys(LANGS).join(', ') + '. No markdown, no explanation.';
}

function getTranslateWithExamplesPrompt() {
  return 'You are a professional translator. The user has a language pair: ' + getSourceName() + ' and ' + getTargetName() + '. Auto-detect the language of the input text. If it is ' + getSourceName() + ', translate to ' + getTargetName() + '. If it is ' + getTargetName() + ', translate to ' + getSourceName() + '. If it is neither, translate to ' + getTargetName() + '. IMPORTANT: Always provide a proper semantic translation of the meaning. Never transliterate or write words phonetically in another script. Since the input is a short word or phrase, also provide 3 example sentences showing how this word/phrase is used in context. Each example must have the sentence in the source language and its translation. In each example, wrap the key word/phrase in <b> tags (both in source and translation). Reply ONLY with this JSON: {"from":"LANG_CODE","text":"TRANSLATED_TEXT","examples":[{"source":"sentence with <b>word</b>","translation":"translated sentence with <b>word</b>"},{"source":"...","translation":"..."},{"source":"...","translation":"..."}]} where LANG_CODE is one of: ' + Object.keys(LANGS).join(', ') + '. No markdown, no explanation outside JSON.';
}

function isShortText(text) {
  const words = text.trim().split(/\s+/);
  return words.length <= 3;
}

function parseTranslateResult(raw) {
  try {
    const json = JSON.parse(raw);
    if (json.text) return { from: json.from, text: json.text, examples: json.examples || null };
  } catch (e) {}
  // Try to extract full JSON with possible examples field
  const fullMatch = raw.match(/\{[\s\S]*"text"\s*:\s*"[^"]*"[\s\S]*\}/);
  if (fullMatch) {
    try {
      const json = JSON.parse(fullMatch[0]);
      if (json.text) return { from: json.from, text: json.text, examples: json.examples || null };
    } catch (e) {}
  }
  // Fallback: match simple {"from":"...","text":"..."} or {"text":"...","from":"..."} precisely
  const m = raw.match(/\{\s*"from"\s*:\s*"[^"]+"\s*,\s*"text"\s*:\s*"((?:[^"\\]|\\[\s\S])*)"\s*\}/) ||
            raw.match(/\{\s*"text"\s*:\s*"((?:[^"\\]|\\[\s\S])*)"\s*,\s*"from"\s*:\s*"[^"]+"\s*\}/);
  if (m) {
    try {
      const json = JSON.parse(m[0]);
      if (json.text) return { from: json.from, text: json.text, examples: null };
    } catch (e2) {}
  }
  return { from: sourceLang, text: raw, examples: null };
}

function renderExamples(examples, containerId, listId) {
  const container = document.getElementById(containerId);
  const list = document.getElementById(listId);
  if (!container || !list) return;
  if (!examples || !Array.isArray(examples) || examples.length === 0) {
    container.classList.remove('visible');
    list.innerHTML = '';
    return;
  }
  list.innerHTML = examples.map(function(ex) {
    return '<div class="example-item">' +
      '<div class="example-source">' + ex.source + '</div>' +
      '<div class="example-translation">' + ex.translation + '</div>' +
    '</div>';
  }).join('');
  container.classList.add('visible');
}

function getOtherLang(detectedLang) {
  if (detectedLang === sourceLang) return targetLang;
  if (detectedLang === targetLang) return sourceLang;
  return targetLang;
}

// ===== TEXT =====
function updateCharCount() {
  document.getElementById('charCount').textContent = document.getElementById('textInput').value.length;
}


async function translateText() {
  const text = document.getElementById('textInput').value.trim();
  if (!text) return;

  const btn = document.getElementById('textTranslateBtn');
  const stopBtn = document.getElementById('textStopBtn');
  btn.disabled = true; btn.textContent = '...';
  stopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    const wantExamples = isShortText(text);
    const prompt = wantExamples ? getTranslateWithExamplesPrompt() : getAutoTranslatePrompt();
    const raw = await callTranslate(
      prompt,
      text,
      wantExamples ? 2048 : 1024,
      currentAbortController.signal
    );
    const r = parseTranslateResult(raw);
    const toLang = getOtherLang(r.from);
    const textResultEl = document.getElementById('textResultText');
    textResultEl.textContent = r.text;
    textResultEl.dataset.lang = LANGS[toLang].tts;
    textResultEl.dataset.sourceLang = r.from;
    textResultEl.dataset.targetLang = toLang;
    textResultEl.dataset.sourceText = text;
    document.getElementById('textResultLabel').textContent = LANGS[toLang].name;
    document.getElementById('textResult').classList.add('visible');
    document.getElementById('textSavePhraseBtn').classList.remove('saved');
    renderExamples(r.examples, 'textExamples', 'textExamplesList');
    prefetchTts(r.text, LANGS[toLang].tts);
    saveTranslation('text', r.from, toLang, text, r.text);
  } catch (e) {
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  btn.disabled = false; btn.textContent = 'Перевести';
  stopBtn.classList.remove('visible');
  currentAbortController = null;
}

function clearTextForm() {
  stopAudio();
  document.getElementById('textInput').value = '';
  document.getElementById('textResultText').textContent = '';
  document.getElementById('textResult').classList.remove('visible');
  renderExamples(null, 'textExamples', 'textExamplesList');
  updateCharCount();
  document.getElementById('textInput').focus();
}

// ===== PHOTO =====
function handlePhoto(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    document.getElementById('photoImg').src = ev.target.result;
    document.getElementById('photoPreview').classList.add('visible');
    document.querySelector('.photo-zone').style.display = 'none';
  };
  reader.readAsDataURL(file);
}

function clearPhoto() {
  document.getElementById('photoPreview').classList.remove('visible');
  document.getElementById('photoOcrResult').classList.remove('visible');
  document.getElementById('photoTransResult').classList.remove('visible');
  document.querySelector('.photo-zone').style.display = 'flex';
  document.getElementById('photoInput').value = '';
}

async function translatePhoto() {
  const imgSrc = document.getElementById('photoImg').src;
  if (!imgSrc) return;
  showToast('Распознаю текст...');

  const photoBtn = document.getElementById('photoTranslateBtn');
  const photoStopBtn = document.getElementById('photoStopBtn');
  photoBtn.disabled = true; photoBtn.textContent = '...';
  photoStopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    const base64 = imgSrc.split(',')[1];
    const mediaType = imgSrc.split(';')[0].split(':')[1];

    const res = await fetch('/api/translate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
      body: JSON.stringify({
        system: 'You are an OCR and translation assistant. First, extract ALL visible text from the image. Then translate it to ' + getTargetName() + '. Detect the source language automatically. IMPORTANT: Provide a proper semantic translation of the meaning, not a transliteration or phonetic transcription into another script. Format your response as:\nOCR: [extracted text]\nTRANSLATION: [translated text]',
        content: [
          { type: 'image', source: { type: 'base64', media_type: mediaType, data: base64 } },
          { type: 'text', text: 'Extract text from this image and translate it to ' + getTargetName() + '.' }
        ],
        max_tokens: 2048
      }),
      signal: currentAbortController.signal
    });
    if (res.status === 401) { showLoginScreen(); throw new Error('Unauthorized'); }

    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'API error');
    const text = data.text;
    const ocrMatch = text.match(/OCR:\s*([\s\S]*?)(?=TRANSLATION:|$)/i);
    const transMatch = text.match(/TRANSLATION:\s*([\s\S]*)/i);

    if (ocrMatch) {
      document.getElementById('photoOcrText').textContent = ocrMatch[1].trim();
      document.getElementById('photoOcrResult').classList.add('visible');
    }
    if (transMatch) {
      document.getElementById('photoTransText').textContent = transMatch[1].trim();
      document.getElementById('photoTransText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('photoTransResult').classList.add('visible');
      prefetchTts(transMatch[1].trim(), LANGS[targetLang].tts);
    }
    if (ocrMatch && transMatch) {
      saveTranslation('photo', sourceLang, targetLang, ocrMatch[1].trim(), transMatch[1].trim());
    }
  } catch (e) {
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  photoBtn.disabled = false; photoBtn.textContent = 'Распознать и перевести';
  photoStopBtn.classList.remove('visible');
  currentAbortController = null;
}

// ===== SPEECH RECOGNITION =====
async function ensureMicPermission() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop());
    return true;
  } catch (e) {
    showToast('Разрешите доступ к микрофону в настройках браузера');
    return false;
  }
}

function getSpeechRecognition() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { showToast('Распознавание речи не поддерживается'); return null; }
  const r = new SR();
  r.continuous = false;
  r.interimResults = true;
  return r;
}

// ===== VOICE =====
async function toggleVoiceRecording() {
  const mic = document.getElementById('voiceMic');
  const status = document.getElementById('voiceStatus');

  if (voiceRecording) { if (recognition) recognition.stop(); return; }

  // Request microphone permission before starting recognition (required on mobile)
  if (!await ensureMicPermission()) return;

  // Stop any playing audio so it doesn't interfere with recording
  stopAudio();

  // Abort previous recognition instance to release mic resources
  if (recognition) {
    try { recognition.abort(); } catch(e) {}
    recognition = null;
  }

  recognition = getSpeechRecognition();
  if (!recognition) return;

  recognition.lang = LANGS[voiceNextLang].speech;
  voiceRecording = true;
  mic.classList.add('recording');
  status.textContent = 'Говорите...';
  status.classList.add('active');

  let finalText = '';

  recognition.onresult = (e) => {
    let interim = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) finalText += e.results[i][0].transcript;
      else interim += e.results[i][0].transcript;
    }
    document.getElementById('voiceTranscript').textContent = finalText + interim;
    document.getElementById('voiceTranscript').classList.add('visible');
  };

  recognition.onend = async () => {
    voiceRecording = false;
    mic.classList.remove('recording');
    status.textContent = 'Нажмите для записи';
    status.classList.remove('active');

    if (finalText.trim()) {
      currentAbortController = new AbortController();
      try {
        const wantExamples = isShortText(finalText.trim());
        const prompt = wantExamples ? getTranslateWithExamplesPrompt() : getAutoTranslatePrompt();
        const raw = await callTranslate(prompt, finalText.trim(), wantExamples ? 2048 : 1024, currentAbortController.signal);
        const r = parseTranslateResult(raw);
        const toLang = getOtherLang(r.from);
        const voiceResultEl = document.getElementById('voiceResultText');
        voiceResultEl.textContent = r.text;
        voiceResultEl.dataset.lang = LANGS[toLang].tts;
        voiceResultEl.dataset.sourceLang = r.from;
        voiceResultEl.dataset.targetLang = toLang;
        voiceResultEl.dataset.sourceText = finalText.trim();
        document.getElementById('voiceResult').classList.add('visible');
        document.getElementById('voiceSavePhraseBtn').classList.remove('saved');
        renderExamples(r.examples, 'voiceExamples', 'voiceExamplesList');
        prefetchTts(r.text, LANGS[toLang].tts);
        saveTranslation('voice', r.from, toLang, finalText.trim(), r.text);
        flipVoiceLang();
      } catch (e) {
        if (e.name !== 'AbortError') { showToast('Ошибка: ' + e.message); }
      }
      currentAbortController = null;
    }
  };

  recognition.onerror = (e) => {
    voiceRecording = false;
    mic.classList.remove('recording');
    if (e.error === 'not-allowed') {
      status.textContent = 'Нет доступа к микрофону';
    } else {
      status.textContent = 'Ошибка: ' + e.error;
    }
    status.classList.remove('active');
  };

  recognition.start();
}

// ===== GENDER DETECTION VIA PITCH ANALYSIS =====
let pitchDetectionStream = null;
let pitchAnalyserSource = null;
let pitchAnalyser = null;
let pitchDetectionInterval = null;
let detectedPitches = [];

// Autocorrelation-based pitch detection
function detectPitch(buffer, sampleRate) {
  // Check signal level — skip if too quiet
  let rms = 0;
  for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / buffer.length);
  if (rms < 0.01) return -1;

  const SIZE = buffer.length;
  const correlations = new Float32Array(SIZE);

  for (let lag = 0; lag < SIZE; lag++) {
    let sum = 0;
    for (let i = 0; i < SIZE - lag; i++) sum += buffer[i] * buffer[i + lag];
    correlations[lag] = sum;
  }

  // Find first dip (where autocorrelation starts decreasing)
  let d = 0;
  while (d < SIZE - 1 && correlations[d] > correlations[d + 1]) d++;

  // Find the highest peak after the dip
  let maxVal = -1, maxPos = -1;
  for (let i = d; i < SIZE; i++) {
    if (correlations[i] > maxVal) { maxVal = correlations[i]; maxPos = i; }
  }

  if (maxPos <= 0) return -1;
  const freq = sampleRate / maxPos;
  // Filter out unreasonable frequencies (human voice: 60–500 Hz)
  return (freq >= 60 && freq <= 500) ? freq : -1;
}

function startPitchDetection() {
  detectedPitches = [];
  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    pitchDetectionStream = stream;
    const ctx = getAudioContext();
    pitchAnalyserSource = ctx.createMediaStreamSource(stream);
    pitchAnalyser = ctx.createAnalyser();
    pitchAnalyser.fftSize = 2048;
    pitchAnalyserSource.connect(pitchAnalyser);

    const buffer = new Float32Array(pitchAnalyser.fftSize);
    pitchDetectionInterval = setInterval(() => {
      pitchAnalyser.getFloatTimeDomainData(buffer);
      const pitch = detectPitch(buffer, ctx.sampleRate);
      if (pitch > 0) detectedPitches.push(pitch);
    }, 100);
  }).catch(() => {});
}

function stopPitchDetection() {
  if (pitchDetectionInterval) { clearInterval(pitchDetectionInterval); pitchDetectionInterval = null; }
  if (pitchAnalyserSource) { try { pitchAnalyserSource.disconnect(); } catch(e) {} pitchAnalyserSource = null; }
  if (pitchDetectionStream) { pitchDetectionStream.getTracks().forEach(t => t.stop()); pitchDetectionStream = null; }
  pitchAnalyser = null;

  if (detectedPitches.length < 3) return null; // Not enough data

  // Use median pitch for robustness against outliers
  const sorted = [...detectedPitches].sort((a, b) => a - b);
  const median = sorted[Math.floor(sorted.length / 2)];

  // Male voice: ~85–180 Hz, Female voice: ~165–255 Hz, threshold ~160 Hz
  const gender = median < 160 ? 'male' : 'female';
  console.log('[Gender] Detected:', gender, '| Median pitch:', Math.round(median), 'Hz | Samples:', detectedPitches.length);
  return gender;
}

// ===== DIALOG =====
function toggleAutoSpeak() {
  autoSpeak = !autoSpeak;
  document.getElementById('autoSpeakToggle').classList.toggle('on', autoSpeak);
}

function addDialogMessage(text, langCode, autoPlay, detectedGender) {
  const container = document.getElementById('dialogMessages');
  if (dialogFirstMessage) { container.innerHTML = ''; dialogFirstMessage = false; }

  const lang = LANGS[langCode];
  const isSource = (langCode === sourceLang);
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble ' + (isSource ? 'msg-source' : 'msg-target');

  const escapedText = text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
  const genderForTts = detectedGender || voiceGender;
  const genderBadge = detectedGender
    ? ' <span class="msg-gender-badge ' + detectedGender + '">' + (detectedGender === 'male' ? '♂' : '♀') + '</span>'
    : '';

  bubble.innerHTML =
    '<div class="msg-label">' + flagImg(lang.flagCode, 16) + genderBadge + '</div>' +
    '<div class="msg-text">' + text + '</div>' +
    '<button class="msg-play" onclick="speakText(\'' + escapedText + '\', \'' + lang.tts + '\', this, \'' + genderForTts + '\')">' +
    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg></button>';

  container.appendChild(bubble);
  container.scrollTop = container.scrollHeight;

  if (autoPlay && autoSpeak) {
    const playBtn = bubble.querySelector('.msg-play');
    speakText(text, lang.tts, playBtn, genderForTts);
  } else {
    // Prefetch even if not auto-playing, so manual play is instant
    prefetchTts(text, lang.tts, genderForTts);
  }
}

function addLoadingBubble() {
  const container = document.getElementById('dialogMessages');
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble msg-target';
  bubble.id = 'loadingBubble';
  bubble.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
  container.appendChild(bubble);
  container.scrollTop = container.scrollHeight;
}

function removeLoadingBubble() {
  const el = document.getElementById('loadingBubble');
  if (el) el.remove();
}

async function sendDialog() {
  const input = document.getElementById('dialogInput');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';

  // Start dialog session on first message
  if (dialogFirstMessage) { startDialogSession(); }

  addLoadingBubble();
  currentAbortController = new AbortController();

  try {
    const raw = await callTranslate(
      getAutoTranslatePrompt() + ' Make the translation sound natural and fluent.',
      text,
      1024,
      currentAbortController.signal
    );
    const r = parseTranslateResult(raw);
    const fromLang = r.from || sourceLang;
    const toLang = getOtherLang(fromLang);
    removeLoadingBubble();
    addDialogMessage(text, fromLang, false);
    addDialogMessage(r.text, toLang, true);
    saveDialogMessages(fromLang, text, toLang, r.text, null);
    flipDialogLang();
  } catch (e) {
    removeLoadingBubble();
    if (e.name !== 'AbortError') {
      showToast('Ошибка: ' + e.message);
    }
  }

  currentAbortController = null;
}

async function toggleDialogRecording() {
  const mic = document.getElementById('dialogMic');

  if (dialogRecording) {
    // User gesture context — resume AudioContext now so auto-speak works in onend
    // (SpeechRecognition interrupts AudioContext on mobile, leaving it suspended)
    try { getAudioContext().resume(); } catch(e) {}
    if (recognition) recognition.stop();
    return;
  }

  // Request microphone permission before starting recognition (required on mobile)
  if (!await ensureMicPermission()) return;

  // Stop any playing audio so it doesn't interfere with recording
  stopAudio();

  // Abort any in-flight translation from a previous recording
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
    removeLoadingBubble();
  }

  // Abort previous recognition instance to release mic resources
  if (recognition) {
    try { recognition.abort(); } catch(e) {}
    recognition = null;
  }

  recognition = getSpeechRecognition();
  if (!recognition) return;

  // Use continuous mode so recognition doesn't cut off mid-phrase on mobile;
  // user explicitly stops by tapping mic again
  recognition.continuous = true;
  recognition.lang = LANGS[dialogNextLang].speech;
  dialogRecording = true;
  mic.classList.add('recording');

  // Start pitch analysis for automatic gender detection
  startPitchDetection();

  let finalText = '';

  recognition.onresult = (e) => {
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) finalText += e.results[i][0].transcript;
    }
  };

  recognition.onend = async () => {
    dialogRecording = false;
    mic.classList.remove('recording');

    // Determine speaker gender from pitch analysis
    const detectedGender = stopPitchDetection();

    if (finalText.trim()) {
      if (dialogFirstMessage) { startDialogSession(); }
      addLoadingBubble();
      currentAbortController = new AbortController();

      try {
        const raw = await callTranslate(
          getAutoTranslatePrompt() + ' Make the translation sound natural and fluent.',
          finalText.trim(),
          1024,
          currentAbortController.signal
        );
        const r = parseTranslateResult(raw);
        const fromLang = r.from || dialogNextLang;
        const toLang = getOtherLang(fromLang);
        removeLoadingBubble();
        addDialogMessage(finalText.trim(), fromLang, false, detectedGender);
        addDialogMessage(r.text, toLang, true, detectedGender);
        saveDialogMessages(fromLang, finalText.trim(), toLang, r.text, detectedGender);
        flipDialogLang();
      } catch (e) {
        removeLoadingBubble();
        if (e.name !== 'AbortError') {
          showToast('Ошибка: ' + e.message);
        }
      }

      currentAbortController = null;
    }
  };

  recognition.onerror = (e) => {
    dialogRecording = false;
    mic.classList.remove('recording');
    stopPitchDetection(); // Clean up pitch analysis on error
    if (e.error === 'not-allowed') {
      showToast('Разрешите доступ к микрофону в настройках браузера');
    } else if (e.error !== 'aborted') {
      showToast('Ошибка записи: ' + e.error);
    }
  };

  recognition.start();
}

// ===== TTS (Web Audio API for mobile compatibility) =====
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
let audioContext = null;
let currentSource = null;
const ttsCache = new Map();
let ttsAbortController = null;
let ttsPlaying = false;

function getAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioContext;
}

// Unlock AudioContext on first user gesture (required on iOS & many mobile browsers).
// AudioContext starts in 'suspended' state and must be resumed from a user gesture.
// Once resumed, programmatic playback via createBufferSource works — including on iOS,
// and AudioContext ignores the iOS silent/ringer switch (unlike HTMLAudioElement).
function unlockAudio() {
  const ctx = getAudioContext();
  if (ctx.state === 'suspended') {
    ctx.resume().then(() => {
      console.log('[TTS] AudioContext unlocked, state:', ctx.state);
    }).catch(() => {});
  }
  // On iOS, also push a tiny silent buffer to fully initialise the audio path
  if (isIOS) {
    try {
      const b = ctx.createBuffer(1, 1, 22050);
      const s = ctx.createBufferSource();
      s.buffer = b;
      s.connect(ctx.destination);
      s.start(0);
    } catch (e) {}
  }
}
document.addEventListener('click', unlockAudio);
document.addEventListener('touchend', unlockAudio, { passive: true });

function clearSpeakingState() {
  document.querySelectorAll('.speaking').forEach(el => el.classList.remove('speaking'));
  const g = document.getElementById('ttsGlobalStop');
  if (g) g.classList.remove('visible');
}

function showGlobalStop() {
  const g = document.getElementById('ttsGlobalStop');
  if (g) g.classList.add('visible');
}

// Split text into sentence-based chunks for progressive TTS playback.
// Shorter chunks mean faster time-to-first-audio since requests run in parallel.
function splitTtsChunks(text) {
  if (text.length < 80) return [text];
  // Split on sentence-ending punctuation followed by whitespace or end
  const parts = text.match(/[^.!?…]+(?:[.!?…]+|$)/g);
  if (!parts || parts.length <= 1) return [text];
  // Merge short fragments to avoid tiny requests
  const merged = [];
  let buf = '';
  for (const p of parts) {
    buf += p;
    if (buf.trim().length >= 40) {
      merged.push(buf.trim());
      buf = '';
    }
  }
  if (buf.trim()) {
    if (merged.length > 0 && buf.trim().length < 30) {
      merged[merged.length - 1] += ' ' + buf.trim();
    } else {
      merged.push(buf.trim());
    }
  }
  // Cap at 6 chunks to limit parallel requests
  while (merged.length > 6) {
    let minLen = Infinity, minIdx = 0;
    for (let i = 0; i < merged.length - 1; i++) {
      const combined = merged[i].length + merged[i + 1].length;
      if (combined < minLen) { minLen = combined; minIdx = i; }
    }
    merged[minIdx] += ' ' + merged[minIdx + 1];
    merged.splice(minIdx + 1, 1);
  }
  return merged;
}

// Fetch and decode a single TTS audio buffer
async function fetchTtsBuffer(text, lang, signal, genderOverride) {
  const voice = genderOverride || voiceGender;
  const res = await fetch('/api/tts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
    body: JSON.stringify({ text, voice, lang }),
    signal
  });
  if (res.status === 401) { showLoginScreen(); throw new Error('Unauthorized'); }
  if (!res.ok) {
    const errBody = await res.json().catch(() => ({}));
    console.warn('[TTS] API error:', res.status, errBody);
    throw new Error('TTS error: ' + res.status);
  }
  const arrayBuffer = await res.arrayBuffer();
  const ctx = getAudioContext();
  // decodeAudioData works on all platforms including iOS Safari (MP3 supported).
  // Must copy the ArrayBuffer since decodeAudioData detaches it.
  return await ctx.decodeAudioData(arrayBuffer.slice(0));
}

// Play decoded AudioBuffer via AudioContext. Works on all platforms including iOS.
// AudioContext.resume() is called in unlockAudio() on user gesture, so by the time
// we get here, the context is 'running' and ignores the iOS silent/ringer switch.
function playBufferAsync(buffer, signal) {
  return new Promise((resolve, reject) => {
    if (signal && signal.aborted) { reject(new Error('aborted')); return; }
    const ctx = getAudioContext();
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(ctx.destination);
    const onAbort = () => {
      try { source.stop(); } catch(e) {}
      reject(new Error('aborted'));
    };
    if (signal) signal.addEventListener('abort', onAbort, { once: true });
    source.onended = () => {
      if (signal) signal.removeEventListener('abort', onAbort);
      if (currentSource === source) currentSource = null;
      resolve();
    };
    currentSource = source;
    source.start(0);
  });
}

async function speakText(text, lang, btn, genderOverride) {
  // If audio is playing, stop it (toggle behavior)
  if (currentSource || ttsPlaying || (window.speechSynthesis && window.speechSynthesis.speaking)) {
    stopAudio();
    return;
  }

  stopAudio();
  clearSpeakingState();
  if (btn) btn.classList.add('speaking');

  const ttsLang = lang || 'en-US';
  const voice = genderOverride || voiceGender;

  try {
    // Resume AudioContext (may be suspended if page was backgrounded).
    // On iOS this is critical — AudioContext must be 'running' before playback.
    const ctx = getAudioContext();
    await ctx.resume();
    if (ctx.state !== 'running') throw new Error('AudioContext suspended');

    // Check full-text cache first
    const fullCacheKey = text + '|' + voice + '|' + ttsLang;
    if (ttsCache.has(fullCacheKey)) {
      showGlobalStop();
      await playBufferAsync(ttsCache.get(fullCacheKey));
      clearSpeakingState();
      return;
    }

    const chunks = splitTtsChunks(text);
    ttsAbortController = new AbortController();
    const signal = ttsAbortController.signal;

    if (chunks.length <= 1) {
      // Single chunk — simple path
      const audioBuffer = await fetchTtsBuffer(text, ttsLang, signal, genderOverride);
      ttsCache.set(fullCacheKey, audioBuffer);
      if (signal.aborted) return;
      showGlobalStop();
      await playBufferAsync(audioBuffer, signal);
      clearSpeakingState();
      return;
    }

    // Multi-chunk: fire all requests in parallel, play in order as they arrive.
    // This dramatically reduces time-to-first-audio for long texts.
    ttsPlaying = true;
    showGlobalStop();

    const bufferPromises = chunks.map(chunk => {
      const chunkKey = chunk + '|' + voice + '|' + ttsLang;
      if (ttsCache.has(chunkKey)) return Promise.resolve(ttsCache.get(chunkKey));
      return fetchTtsBuffer(chunk, ttsLang, signal, genderOverride).then(buf => {
        ttsCache.set(chunkKey, buf);
        return buf;
      });
    });

    // Play chunks sequentially — each starts as soon as its audio is ready
    for (let i = 0; i < bufferPromises.length; i++) {
      if (signal.aborted) break;
      const buffer = await bufferPromises[i];
      if (signal.aborted) break;
      await playBufferAsync(buffer, signal);
    }

    ttsPlaying = false;
    ttsAbortController = null;
    clearSpeakingState();
  } catch (e) {
    ttsPlaying = false;
    ttsAbortController = null;
    if (e.message === 'aborted') { clearSpeakingState(); return; }
    console.warn('[TTS] Falling back to browser speech. lang=' + ttsLang, e.message);
    clearSpeakingState();
    // Fallback to browser TTS
    if ('speechSynthesis' in window) {
      const u = new SpeechSynthesisUtterance(text);
      u.lang = ttsLang; u.rate = 0.9;
      const baseLang = ttsLang.split('-')[0];
      const voices = window.speechSynthesis.getVoices();
      // Prefer Google online voices for better multilingual support
      const match = voices.find(v => v.lang === ttsLang && v.name.includes('Google'))
        || voices.find(v => v.lang === ttsLang)
        || voices.find(v => v.lang.startsWith(baseLang + '-') && v.name.includes('Google'))
        || voices.find(v => v.lang.startsWith(baseLang + '-'))
        || voices.find(v => v.lang.startsWith(baseLang));
      if (match) {
        u.voice = match; u.lang = match.lang;
        console.log('[TTS] Browser voice:', match.name, match.lang);
      } else {
        // No matching voice found — don't speak in the wrong language
        console.warn('[TTS] No voice found for', ttsLang, '— available:', voices.map(v => v.lang + ':' + v.name).join(', '));
        clearSpeakingState();
        showToast('Голос для этого языка недоступен');
        return;
      }
      u.onend = () => clearSpeakingState();
      if (btn) btn.classList.add('speaking');
      showGlobalStop();
      window.speechSynthesis.speak(u);
    }
  }
}

// Prefetch TTS audio in the background right after translation completes.
// By the time the user clicks the speaker button, audio is already cached.
function prefetchTts(text, lang, genderOverride) {
  if (!text || text.length < 2) return;
  const ttsLang = lang || 'en-US';
  const voice = genderOverride || voiceGender;
  const fullCacheKey = text + '|' + voice + '|' + ttsLang;
  if (ttsCache.has(fullCacheKey)) return; // already cached
  const chunks = splitTtsChunks(text);
  if (chunks.length <= 1) {
    fetchTtsBuffer(text, ttsLang, null, genderOverride).then(buf => {
      ttsCache.set(fullCacheKey, buf);
      console.log('[TTS] Prefetched audio for:', text.substring(0, 40) + '…');
    }).catch(() => {});
  } else {
    chunks.forEach(chunk => {
      const chunkKey = chunk + '|' + voice + '|' + ttsLang;
      if (!ttsCache.has(chunkKey)) {
        fetchTtsBuffer(chunk, ttsLang, null, genderOverride).then(buf => {
          ttsCache.set(chunkKey, buf);
        }).catch(() => {});
      }
    });
    console.log('[TTS] Prefetching', chunks.length, 'chunks for:', text.substring(0, 40) + '…');
  }
}

function speakResult(elementId, btn) {
  const el = document.getElementById(elementId);
  const text = el.textContent;
  const lang = el.dataset.lang || LANGS[targetLang].tts;
  speakText(text, lang, btn);
}

if ('speechSynthesis' in window) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
}

// ===== UTILS =====
function copyResult(elementId) {
  const text = document.getElementById(elementId).textContent;
  navigator.clipboard.writeText(text).then(() => showToast('Скопировано'));
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('visible');
  setTimeout(() => t.classList.remove('visible'), 2500);
}

// ===== ABORT CONTROLLER FOR STOPPING =====
let currentAbortController = null;

function stopCurrentOperation() {
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
  }
  stopAudio();
  showToast('Остановлено');
}

function stopAudio() {
  // Abort any in-flight TTS requests
  if (ttsAbortController) {
    ttsAbortController.abort();
    ttsAbortController = null;
  }
  ttsPlaying = false;
  if (currentSource) {
    try { currentSource.stop(); } catch(e) {}
    currentSource = null;
  }
  if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  clearSpeakingState();
}

// ===== FILE UPLOAD =====
let uploadedFileContent = '';
let uploadedFileName = '';
let uploadedFileType = 'text'; // 'text', 'image', 'pdf'
let uploadedFileBase64 = '';
let uploadedFileMediaType = '';

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' Б';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' КБ';
  return (bytes / (1024 * 1024)).toFixed(1) + ' МБ';
}

function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
  const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg', '.tiff', '.tif', '.ico', '.heic', '.heif', '.avif'];
  const unsupportedExts = ['.doc', '.xlsx', '.xls', '.pptx', '.ppt', '.zip', '.rar', '.7z', '.gz', '.tar', '.exe', '.bin', '.odt', '.ods', '.epub'];

  if (unsupportedExts.includes(ext)) {
    showToast('Формат ' + ext + ' не поддерживается.');
    return;
  }

  const isImage = imageExts.includes(ext) || file.type.startsWith('image/');
  const isPdf = ext === '.pdf';
  const isDocx = ext === '.docx';
  const isBinary = isImage || isPdf || isDocx;

  const maxSize = isBinary ? 10 * 1024 * 1024 : 100 * 1024;
  const maxLabel = isBinary ? '10 МБ' : '100 КБ';

  if (file.size > maxSize) {
    showToast('Файл слишком большой (макс. ' + maxLabel + ')');
    return;
  }

  if (isImage) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      const dataUrl = ev.target.result;
      uploadedFileType = 'image';
      uploadedFileBase64 = dataUrl.split(',')[1];
      uploadedFileMediaType = dataUrl.split(';')[0].split(':')[1];
      uploadedFileName = file.name;
      uploadedFileContent = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').src = dataUrl;
      document.getElementById('fileImagePreview').style.display = 'block';
      document.getElementById('filePreview').classList.remove('visible');
    };
    reader.readAsDataURL(file);
  } else if (isPdf) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      const dataUrl = ev.target.result;
      uploadedFileType = 'pdf';
      uploadedFileBase64 = dataUrl.split(',')[1];
      uploadedFileMediaType = 'application/pdf';
      uploadedFileName = file.name;
      uploadedFileContent = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').style.display = 'none';
      document.getElementById('filePreview').textContent = 'PDF документ — ' + formatFileSize(file.size);
      document.getElementById('filePreview').classList.add('visible');
    };
    reader.readAsDataURL(file);
  } else if (isDocx) {
    const reader = new FileReader();
    reader.onload = async (ev) => {
      try {
        if (typeof mammoth === 'undefined') {
          showToast('Библиотека для DOCX не загружена. Проверьте соединение.');
          return;
        }
        const result = await mammoth.extractRawText({ arrayBuffer: ev.target.result });
        const text = result.value;
        if (!text.trim()) {
          showToast('Не удалось извлечь текст из документа');
          return;
        }
        uploadedFileType = 'text';
        uploadedFileContent = text;
        uploadedFileName = file.name;
        uploadedFileBase64 = '';
        uploadedFileMediaType = '';
        showFileInfo(file.name, file.size);
        document.getElementById('fileImagePreview').style.display = 'none';
        const preview = text.substring(0, 500);
        document.getElementById('filePreview').textContent = preview + (text.length > 500 ? '...' : '');
        document.getElementById('filePreview').classList.add('visible');
      } catch (err) {
        showToast('Ошибка чтения DOCX: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
  } else {
    // Text files
    const reader = new FileReader();
    reader.onload = (ev) => {
      const text = ev.target.result;
      let nonPrintable = 0;
      for (let i = 0; i < Math.min(text.length, 1000); i++) {
        const c = text.charCodeAt(i);
        if (c < 32 && c !== 9 && c !== 10 && c !== 13) nonPrintable++;
      }
      if (nonPrintable > 20) {
        showToast('Файл содержит бинарные данные.');
        return;
      }
      uploadedFileType = 'text';
      uploadedFileContent = text;
      uploadedFileName = file.name;
      uploadedFileBase64 = '';
      uploadedFileMediaType = '';
      showFileInfo(file.name, file.size);
      document.getElementById('fileImagePreview').style.display = 'none';
      const preview = text.substring(0, 500);
      document.getElementById('filePreview').textContent = preview + (text.length > 500 ? '...' : '');
      document.getElementById('filePreview').classList.add('visible');
    };
    reader.readAsText(file, 'UTF-8');
  }
}

function showFileInfo(name, size) {
  document.getElementById('fileName').textContent = name;
  document.getElementById('fileSize').textContent = formatFileSize(size);
  document.getElementById('fileInfo').classList.add('visible');
  document.getElementById('fileZone').style.display = 'none';
  document.getElementById('fileResult').classList.remove('visible');
}

function clearFile() {
  uploadedFileContent = '';
  uploadedFileName = '';
  uploadedFileType = 'text';
  uploadedFileBase64 = '';
  uploadedFileMediaType = '';
  document.getElementById('fileInfo').classList.remove('visible');
  document.getElementById('fileResult').classList.remove('visible');
  document.getElementById('fileZone').style.display = 'flex';
  document.getElementById('fileInput').value = '';
  document.getElementById('fileImagePreview').style.display = 'none';
}

async function translateFile() {
  if (uploadedFileType === 'text' && !uploadedFileContent) return;
  if ((uploadedFileType === 'image' || uploadedFileType === 'pdf') && !uploadedFileBase64) return;

  const btn = document.getElementById('fileTranslateBtn');
  const stopBtn = document.getElementById('fileStopBtn');
  btn.disabled = true;
  btn.textContent = 'Перевожу...';
  stopBtn.classList.add('visible');

  currentAbortController = new AbortController();

  try {
    if (uploadedFileType === 'image') {
      const res = await fetch('/api/translate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify({
          system: 'You are an OCR and translation assistant. Extract ALL visible text from the image. Then translate the extracted text to ' + getTargetName() + '. Detect the source language automatically. IMPORTANT: Provide a proper semantic translation, not transliteration. Reply with ONLY the translated text, no explanations or labels.',
          content: [
            { type: 'image', source: { type: 'base64', media_type: uploadedFileMediaType, data: uploadedFileBase64 } },
            { type: 'text', text: 'Extract all text from this image and translate it to ' + getTargetName() + '. Reply with ONLY the translated text.' }
          ],
          max_tokens: 4096
        }),
        signal: currentAbortController.signal
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'API error');
      document.getElementById('fileResultText').textContent = data.text;
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');
      prefetchTts(data.text, LANGS[targetLang].tts);
      saveTranslation('file', sourceLang, targetLang, '[image: ' + uploadedFileName + ']', data.text.substring(0, 2000), { filename: uploadedFileName });

    } else if (uploadedFileType === 'pdf') {
      const res = await fetch('/api/translate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify({
          system: 'You are a document translation assistant. Extract ALL text from this PDF document. Then translate it to ' + getTargetName() + '. Detect the source language automatically. Keep the structure and formatting. IMPORTANT: Provide a proper semantic translation, not transliteration. Reply with ONLY the translated text, no explanations or labels.',
          content: [
            { type: 'document', source: { type: 'base64', media_type: 'application/pdf', data: uploadedFileBase64 } },
            { type: 'text', text: 'Extract all text from this PDF and translate it to ' + getTargetName() + '. Reply with ONLY the translated text.' }
          ],
          max_tokens: 4096
        }),
        signal: currentAbortController.signal
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'API error');
      document.getElementById('fileResultText').textContent = data.text;
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');
      prefetchTts(data.text, LANGS[targetLang].tts);
      saveTranslation('file', sourceLang, targetLang, '[pdf: ' + uploadedFileName + ']', data.text.substring(0, 2000), { filename: uploadedFileName });

    } else {
      // Text file — chunked translation
      const maxChunkSize = 2000;
      const chunks = [];
      let text = uploadedFileContent;

      if (text.length <= maxChunkSize) {
        chunks.push(text);
      } else {
        const lines = text.split('\n');
        let current = '';
        for (const line of lines) {
          if (current.length + line.length + 1 > maxChunkSize && current.length > 0) {
            chunks.push(current);
            current = line;
          } else {
            current += (current ? '\n' : '') + line;
          }
        }
        if (current) chunks.push(current);
      }

      const results = [];
      for (let i = 0; i < chunks.length; i++) {
        if (currentAbortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');

        if (chunks.length > 1) {
          btn.textContent = 'Часть ' + (i + 1) + '/' + chunks.length + '...';
        }

        const res = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
          body: JSON.stringify({
            system: 'You are a professional translator. Translate the following text from ' + getSourceName() + ' to ' + getTargetName() + '. Keep the original formatting (line breaks, indentation, structure). Translate ONLY the text content, preserving any markup tags, code, or special characters. IMPORTANT: Provide a proper semantic translation, not a transliteration or phonetic transcription into another script. Reply with ONLY the translated text, no explanations.',
            content: chunks[i],
            max_tokens: 4096
          }),
          signal: currentAbortController.signal
        });

        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'API error: ' + res.status);
        results.push(data.text);
      }

      document.getElementById('fileResultText').textContent = results.join('\n');
      document.getElementById('fileResultText').dataset.lang = LANGS[targetLang].tts;
      document.getElementById('fileResultLabel').textContent = LANGS[targetLang].name;
      document.getElementById('fileResult').classList.add('visible');
      prefetchTts(results.join('\n'), LANGS[targetLang].tts);
      saveTranslation('file', sourceLang, targetLang, uploadedFileContent.substring(0, 500), results.join('\n').substring(0, 2000), { filename: uploadedFileName });
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      showToast('Перевод остановлен');
    } else {
      showToast('Ошибка: ' + e.message);
    }
  }

  btn.disabled = false;
  btn.textContent = 'Перевести файл';
  stopBtn.classList.remove('visible');
  currentAbortController = null;
}

function downloadTranslation() {
  const text = document.getElementById('fileResultText').textContent;
  if (!text) return;

  const ext = uploadedFileName.includes('.') ? uploadedFileName.substring(uploadedFileName.lastIndexOf('.')) : '.txt';
  const baseName = uploadedFileName.includes('.') ? uploadedFileName.substring(0, uploadedFileName.lastIndexOf('.')) : uploadedFileName;
  const newName = baseName + '_' + targetLang + ext;

  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = newName;
  a.click();
  URL.revokeObjectURL(url);
  showToast('Файл скачан');
}

// Drag and drop for file zone
document.addEventListener('DOMContentLoaded', () => {
  const zone = document.getElementById('fileZone');
  if (!zone) return;

  zone.addEventListener('dragover', (e) => {
    e.preventDefault();
    zone.classList.add('dragover');
  });
  zone.addEventListener('dragleave', () => {
    zone.classList.remove('dragover');
  });
  zone.addEventListener('drop', (e) => {
    e.preventDefault();
    zone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) {
      // Create a synthetic event for handleFileUpload
      const dt = new DataTransfer();
      dt.items.add(file);
      document.getElementById('fileInput').files = dt.files;
      handleFileUpload({ target: { files: [file] } });
    }
  });
});

// ===== INDEXEDDB — OFFLINE CACHE =====
const DB_NAME = 'traveltalk_offline';
const DB_VERSION = 2;
let offlineDb = null;

function openOfflineDB() {
  return new Promise((resolve, reject) => {
    if (offlineDb) { resolve(offlineDb); return; }
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('translations')) {
        const store = db.createObjectStore('translations', { keyPath: 'id', autoIncrement: true });
        store.createIndex('lookup', ['source_lang', 'target_lang', 'source_text'], { unique: false });
        store.createIndex('by_date', 'created_at', { unique: false });
      }
      if (!db.objectStoreNames.contains('custom_phrases')) {
        db.createObjectStore('custom_phrases', { keyPath: 'key' });
      }
    };
    req.onsuccess = (e) => { offlineDb = e.target.result; resolve(offlineDb); };
    req.onerror = () => reject(req.error);
  });
}

async function saveCustomPhrasesToDB(phrases) {
  try {
    const db = await openOfflineDB();
    const tx = db.transaction('custom_phrases', 'readwrite');
    const store = tx.objectStore('custom_phrases');
    store.put({ key: 'phrases', data: phrases });
  } catch (e) { console.warn('[Offline] Custom phrases write error:', e); }
}

async function getCustomPhrasesFromDB() {
  try {
    const db = await openOfflineDB();
    const tx = db.transaction('custom_phrases', 'readonly');
    const store = tx.objectStore('custom_phrases');
    return new Promise((resolve) => {
      const req = store.get('phrases');
      req.onsuccess = () => resolve(req.result ? req.result.data : []);
      req.onerror = () => resolve([]);
    });
  } catch (e) { return []; }
}

async function cacheTranslation(srcLang, tgtLang, sourceText, translatedText, mode) {
  try {
    const db = await openOfflineDB();
    const tx = db.transaction('translations', 'readwrite');
    const store = tx.objectStore('translations');
    store.put({
      source_lang: srcLang,
      target_lang: tgtLang,
      source_text: sourceText.trim().toLowerCase(),
      source_text_original: sourceText.trim(),
      translated_text: translatedText,
      mode: mode || 'text',
      created_at: new Date().toISOString()
    });
  } catch (e) { console.warn('[Offline] Cache write error:', e); }
}

async function findCachedTranslation(srcLang, tgtLang, sourceText) {
  try {
    const db = await openOfflineDB();
    const tx = db.transaction('translations', 'readonly');
    const store = tx.objectStore('translations');
    const index = store.index('lookup');
    const key = [srcLang, tgtLang, sourceText.trim().toLowerCase()];
    return new Promise((resolve) => {
      const req = index.get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => resolve(null);
    });
  } catch (e) { return null; }
}

async function getRecentCachedTranslations(limit) {
  try {
    const db = await openOfflineDB();
    const tx = db.transaction('translations', 'readonly');
    const store = tx.objectStore('translations');
    const index = store.index('by_date');
    return new Promise((resolve) => {
      const results = [];
      const req = index.openCursor(null, 'prev');
      req.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor && results.length < (limit || 50)) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      req.onerror = () => resolve([]);
    });
  } catch (e) { return []; }
}

// Patch saveTranslation to also cache locally
const _origSaveTranslation = saveTranslation;
saveTranslation = function(mode, srcLang, tgtLang, sourceText, translatedText, metadata) {
  _origSaveTranslation(mode, srcLang, tgtLang, sourceText, translatedText, metadata);
  cacheTranslation(srcLang, tgtLang, sourceText, translatedText, mode);
};

// ===== OFFLINE DETECTION =====
let isOffline = !navigator.onLine;

function updateOfflineState() {
  isOffline = !navigator.onLine;
  const banner = document.getElementById('offlineBanner');
  if (banner) banner.classList.toggle('visible', isOffline);
}

window.addEventListener('online', updateOfflineState);
window.addEventListener('offline', updateOfflineState);
document.addEventListener('DOMContentLoaded', () => {
  updateOfflineState();
  openOfflineDB().catch(() => {});
});

// ===== TRAVEL PHRASEBOOK =====
const PHRASEBOOK = {
  greetings: {
    icon: '👋',
    name: { ru: 'Приветствия', en: 'Greetings' },
    phrases: [
      { ru: 'Здравствуйте', en: 'Hello', de: 'Hallo', fr: 'Bonjour', it: 'Buongiorno', es: 'Hola', 'pt-BR': 'Olá', el: 'Γεια σας' },
      { ru: 'До свидания', en: 'Goodbye', de: 'Auf Wiedersehen', fr: 'Au revoir', it: 'Arrivederci', es: 'Adiós', 'pt-BR': 'Tchau', el: 'Αντίο' },
      { ru: 'Спасибо', en: 'Thank you', de: 'Danke', fr: 'Merci', it: 'Grazie', es: 'Gracias', 'pt-BR': 'Obrigado', el: 'Ευχαριστώ' },
      { ru: 'Пожалуйста', en: 'Please', de: 'Bitte', fr: "S'il vous plaît", it: 'Per favore', es: 'Por favor', 'pt-BR': 'Por favor', el: 'Παρακαλώ' },
      { ru: 'Извините', en: 'Excuse me', de: 'Entschuldigung', fr: 'Excusez-moi', it: 'Mi scusi', es: 'Disculpe', 'pt-BR': 'Com licença', el: 'Συγγνώμη' },
      { ru: 'Да', en: 'Yes', de: 'Ja', fr: 'Oui', it: 'Sì', es: 'Sí', 'pt-BR': 'Sim', el: 'Ναι' },
      { ru: 'Нет', en: 'No', de: 'Nein', fr: 'Non', it: 'No', es: 'No', 'pt-BR': 'Não', el: 'Όχι' },
      { ru: 'Доброе утро', en: 'Good morning', de: 'Guten Morgen', fr: 'Bonjour', it: 'Buongiorno', es: 'Buenos días', 'pt-BR': 'Bom dia', el: 'Καλημέρα' },
      { ru: 'Добрый вечер', en: 'Good evening', de: 'Guten Abend', fr: 'Bonsoir', it: 'Buonasera', es: 'Buenas tardes', 'pt-BR': 'Boa noite', el: 'Καλησπέρα' },
      { ru: 'Как дела?', en: 'How are you?', de: 'Wie geht es Ihnen?', fr: 'Comment allez-vous?', it: 'Come sta?', es: '¿Cómo está?', 'pt-BR': 'Como vai?', el: 'Πώς είστε;' },
    ]
  },
  restaurant: {
    icon: '🍽️',
    name: { ru: 'Ресторан', en: 'Restaurant' },
    phrases: [
      { ru: 'Столик на двоих, пожалуйста', en: 'A table for two, please', de: 'Einen Tisch für zwei, bitte', fr: 'Une table pour deux, s\'il vous plaît', it: 'Un tavolo per due, per favore', es: 'Una mesa para dos, por favor', 'pt-BR': 'Uma mesa para dois, por favor', el: 'Ένα τραπέζι για δύο, παρακαλώ' },
      { ru: 'Можно меню?', en: 'Can I see the menu?', de: 'Kann ich die Speisekarte sehen?', fr: 'Puis-je voir le menu?', it: 'Posso vedere il menu?', es: '¿Puedo ver el menú?', 'pt-BR': 'Posso ver o cardápio?', el: 'Μπορώ να δω το μενού;' },
      { ru: 'Счёт, пожалуйста', en: 'The bill, please', de: 'Die Rechnung, bitte', fr: "L'addition, s'il vous plaît", it: 'Il conto, per favore', es: 'La cuenta, por favor', 'pt-BR': 'A conta, por favor', el: 'Τον λογαριασμό, παρακαλώ' },
      { ru: 'Что вы рекомендуете?', en: 'What do you recommend?', de: 'Was empfehlen Sie?', fr: 'Que recommandez-vous?', it: 'Cosa consiglia?', es: '¿Qué recomienda?', 'pt-BR': 'O que você recomenda?', el: 'Τι προτείνετε;' },
      { ru: 'Я вегетарианец', en: 'I am a vegetarian', de: 'Ich bin Vegetarier', fr: 'Je suis végétarien', it: 'Sono vegetariano', es: 'Soy vegetariano', 'pt-BR': 'Sou vegetariano', el: 'Είμαι χορτοφάγος' },
      { ru: 'У меня аллергия на...', en: 'I am allergic to...', de: 'Ich bin allergisch gegen...', fr: 'Je suis allergique à...', it: 'Sono allergico a...', es: 'Soy alérgico a...', 'pt-BR': 'Sou alérgico a...', el: 'Είμαι αλλεργικός σε...' },
      { ru: 'Воду, пожалуйста', en: 'Water, please', de: 'Wasser, bitte', fr: "De l'eau, s'il vous plaît", it: "Dell'acqua, per favore", es: 'Agua, por favor', 'pt-BR': 'Água, por favor', el: 'Νερό, παρακαλώ' },
      { ru: 'Очень вкусно!', en: 'Very delicious!', de: 'Sehr lecker!', fr: 'Très délicieux!', it: 'Molto buono!', es: '¡Muy delicioso!', 'pt-BR': 'Muito gostoso!', el: 'Πολύ νόστιμο!' },
    ]
  },
  hotel: {
    icon: '🏨',
    name: { ru: 'Отель', en: 'Hotel' },
    phrases: [
      { ru: 'У меня бронь', en: 'I have a reservation', de: 'Ich habe eine Reservierung', fr: "J'ai une réservation", it: 'Ho una prenotazione', es: 'Tengo una reserva', 'pt-BR': 'Eu tenho uma reserva', el: 'Έχω κράτηση' },
      { ru: 'Во сколько выезд?', en: 'What time is checkout?', de: 'Wann ist der Check-out?', fr: "À quelle heure est le départ?", it: 'A che ora è il check-out?', es: '¿A qué hora es el check-out?', 'pt-BR': 'A que horas é o checkout?', el: 'Τι ώρα είναι η αναχώρηση;' },
      { ru: 'Какой пароль от Wi-Fi?', en: 'What is the Wi-Fi password?', de: 'Wie ist das WLAN-Passwort?', fr: 'Quel est le mot de passe Wi-Fi?', it: 'Qual è la password del Wi-Fi?', es: '¿Cuál es la contraseña del Wi-Fi?', 'pt-BR': 'Qual é a senha do Wi-Fi?', el: 'Ποιος είναι ο κωδικός Wi-Fi;' },
      { ru: 'Можно ещё одно полотенце?', en: 'Can I have an extra towel?', de: 'Kann ich ein extra Handtuch bekommen?', fr: 'Puis-je avoir une serviette supplémentaire?', it: 'Posso avere un asciugamano in più?', es: '¿Puedo tener una toalla extra?', 'pt-BR': 'Posso ter uma toalha extra?', el: 'Μπορώ να έχω μια επιπλέον πετσέτα;' },
      { ru: 'Где лифт?', en: 'Where is the elevator?', de: 'Wo ist der Aufzug?', fr: "Où est l'ascenseur?", it: "Dov'è l'ascensore?", es: '¿Dónde está el ascensor?', 'pt-BR': 'Onde é o elevador?', el: 'Πού είναι το ασανσέρ;' },
      { ru: 'Кондиционер не работает', en: 'The air conditioning is not working', de: 'Die Klimaanlage funktioniert nicht', fr: 'La climatisation ne fonctionne pas', it: "L'aria condizionata non funziona", es: 'El aire acondicionado no funciona', 'pt-BR': 'O ar-condicionado não está funcionando', el: 'Ο κλιματισμός δεν λειτουργεί' },
    ]
  },
  transport: {
    icon: '🚕',
    name: { ru: 'Транспорт', en: 'Transport' },
    phrases: [
      { ru: 'Как добраться до...?', en: 'How do I get to...?', de: 'Wie komme ich zu...?', fr: 'Comment aller à...?', it: 'Come arrivo a...?', es: '¿Cómo llego a...?', 'pt-BR': 'Como chego a...?', el: 'Πώς πάω στο...;' },
      { ru: 'Сколько стоит такси до...?', en: 'How much is a taxi to...?', de: 'Was kostet ein Taxi zu...?', fr: 'Combien coûte un taxi pour...?', it: 'Quanto costa un taxi per...?', es: '¿Cuánto cuesta un taxi a...?', 'pt-BR': 'Quanto custa um táxi para...?', el: 'Πόσο κοστίζει ένα ταξί για...;' },
      { ru: 'Где ближайшая станция метро?', en: 'Where is the nearest metro station?', de: 'Wo ist die nächste U-Bahn-Station?', fr: 'Où est la station de métro la plus proche?', it: "Dov'è la stazione della metro più vicina?", es: '¿Dónde está la estación de metro más cercana?', 'pt-BR': 'Onde é a estação de metrô mais próxima?', el: 'Πού είναι ο πλησιέστερος σταθμός μετρό;' },
      { ru: 'Остановите здесь, пожалуйста', en: 'Stop here, please', de: 'Halten Sie hier, bitte', fr: 'Arrêtez ici, s\'il vous plaît', it: 'Si fermi qui, per favore', es: 'Pare aquí, por favor', 'pt-BR': 'Pare aqui, por favor', el: 'Σταματήστε εδώ, παρακαλώ' },
      { ru: 'Где автобусная остановка?', en: 'Where is the bus stop?', de: 'Wo ist die Bushaltestelle?', fr: "Où est l'arrêt de bus?", it: "Dov'è la fermata dell'autobus?", es: '¿Dónde está la parada de autobús?', 'pt-BR': 'Onde é o ponto de ônibus?', el: 'Πού είναι η στάση λεωφορείου;' },
      { ru: 'Один билет до...', en: 'One ticket to...', de: 'Eine Fahrkarte nach...', fr: 'Un billet pour...', it: 'Un biglietto per...', es: 'Un billete a...', 'pt-BR': 'Uma passagem para...', el: 'Ένα εισιτήριο για...' },
      { ru: 'Где аэропорт?', en: 'Where is the airport?', de: 'Wo ist der Flughafen?', fr: "Où est l'aéroport?", it: "Dov'è l'aeroporto?", es: '¿Dónde está el aeropuerto?', 'pt-BR': 'Onde é o aeroporto?', el: 'Πού είναι το αεροδρόμιο;' },
    ]
  },
  shopping: {
    icon: '🛍️',
    name: { ru: 'Магазин', en: 'Shopping' },
    phrases: [
      { ru: 'Сколько это стоит?', en: 'How much does it cost?', de: 'Wie viel kostet das?', fr: 'Combien ça coûte?', it: 'Quanto costa?', es: '¿Cuánto cuesta?', 'pt-BR': 'Quanto custa?', el: 'Πόσο κοστίζει;' },
      { ru: 'Можно примерить?', en: 'Can I try it on?', de: 'Kann ich es anprobieren?', fr: 'Puis-je l\'essayer?', it: 'Posso provarlo?', es: '¿Puedo probármelo?', 'pt-BR': 'Posso experimentar?', el: 'Μπορώ να το δοκιμάσω;' },
      { ru: 'Есть ли скидка?', en: 'Is there a discount?', de: 'Gibt es einen Rabatt?', fr: 'Y a-t-il une réduction?', it: "C'è uno sconto?", es: '¿Hay descuento?', 'pt-BR': 'Tem desconto?', el: 'Υπάρχει έκπτωση;' },
      { ru: 'Принимаете карты?', en: 'Do you accept cards?', de: 'Nehmen Sie Karten an?', fr: 'Acceptez-vous les cartes?', it: 'Accettate carte?', es: '¿Aceptan tarjetas?', 'pt-BR': 'Aceitam cartão?', el: 'Δέχεστε κάρτες;' },
      { ru: 'Где ближайший банкомат?', en: 'Where is the nearest ATM?', de: 'Wo ist der nächste Geldautomat?', fr: 'Où est le distributeur le plus proche?', it: "Dov'è il bancomat più vicino?", es: '¿Dónde está el cajero más cercano?', 'pt-BR': 'Onde é o caixa eletrônico mais próximo?', el: 'Πού είναι το πλησιέστερο ATM;' },
      { ru: 'Мне нужен пакет', en: 'I need a bag', de: 'Ich brauche eine Tüte', fr: "J'ai besoin d'un sac", it: 'Ho bisogno di un sacchetto', es: 'Necesito una bolsa', 'pt-BR': 'Preciso de uma sacola', el: 'Χρειάζομαι μια σακούλα' },
    ]
  },
  emergency: {
    icon: '🚨',
    name: { ru: 'Экстренные', en: 'Emergency' },
    phrases: [
      { ru: 'Помогите!', en: 'Help!', de: 'Hilfe!', fr: 'Au secours!', it: 'Aiuto!', es: '¡Ayuda!', 'pt-BR': 'Socorro!', el: 'Βοήθεια!' },
      { ru: 'Вызовите скорую!', en: 'Call an ambulance!', de: 'Rufen Sie einen Krankenwagen!', fr: 'Appelez une ambulance!', it: "Chiamate un'ambulanza!", es: '¡Llame a una ambulancia!', 'pt-BR': 'Chame uma ambulância!', el: 'Καλέστε ασθενοφόρο!' },
      { ru: 'Вызовите полицию!', en: 'Call the police!', de: 'Rufen Sie die Polizei!', fr: 'Appelez la police!', it: 'Chiamate la polizia!', es: '¡Llame a la policía!', 'pt-BR': 'Chame a polícia!', el: 'Καλέστε την αστυνομία!' },
      { ru: 'Мне нужен врач', en: 'I need a doctor', de: 'Ich brauche einen Arzt', fr: "J'ai besoin d'un médecin", it: 'Ho bisogno di un medico', es: 'Necesito un médico', 'pt-BR': 'Preciso de um médico', el: 'Χρειάζομαι γιατρό' },
      { ru: 'Где ближайшая аптека?', en: 'Where is the nearest pharmacy?', de: 'Wo ist die nächste Apotheke?', fr: 'Où est la pharmacie la plus proche?', it: "Dov'è la farmacia più vicina?", es: '¿Dónde está la farmacia más cercana?', 'pt-BR': 'Onde é a farmácia mais próxima?', el: 'Πού είναι το πλησιέστερο φαρμακείο;' },
      { ru: 'Я потерял паспорт', en: 'I lost my passport', de: 'Ich habe meinen Reisepass verloren', fr: "J'ai perdu mon passeport", it: 'Ho perso il passaporto', es: 'Perdí mi pasaporte', 'pt-BR': 'Perdi meu passaporte', el: 'Έχασα το διαβατήριό μου' },
      { ru: 'Где посольство?', en: 'Where is the embassy?', de: 'Wo ist die Botschaft?', fr: "Où est l'ambassade?", it: "Dov'è l'ambasciata?", es: '¿Dónde está la embajada?', 'pt-BR': 'Onde é a embaixada?', el: 'Πού είναι η πρεσβεία;' },
      { ru: 'Мне плохо', en: 'I feel sick', de: 'Mir ist schlecht', fr: 'Je me sens mal', it: 'Mi sento male', es: 'Me siento mal', 'pt-BR': 'Estou me sentindo mal', el: 'Δεν αισθάνομαι καλά' },
    ]
  },
  navigation: {
    icon: '🗺️',
    name: { ru: 'Навигация', en: 'Navigation' },
    phrases: [
      { ru: 'Где находится...?', en: 'Where is...?', de: 'Wo ist...?', fr: 'Où est...?', it: "Dov'è...?", es: '¿Dónde está...?', 'pt-BR': 'Onde fica...?', el: 'Πού είναι...;' },
      { ru: 'Направо', en: 'Turn right', de: 'Rechts abbiegen', fr: 'Tournez à droite', it: 'Giri a destra', es: 'Gire a la derecha', 'pt-BR': 'Vire à direita', el: 'Στρίψτε δεξιά' },
      { ru: 'Налево', en: 'Turn left', de: 'Links abbiegen', fr: 'Tournez à gauche', it: 'Giri a sinistra', es: 'Gire a la izquierda', 'pt-BR': 'Vire à esquerda', el: 'Στρίψτε αριστερά' },
      { ru: 'Прямо', en: 'Go straight', de: 'Geradeaus', fr: 'Tout droit', it: 'Dritto', es: 'Siga recto', 'pt-BR': 'Siga em frente', el: 'Ευθεία' },
      { ru: 'Это далеко?', en: 'Is it far?', de: 'Ist es weit?', fr: 'Est-ce loin?', it: 'È lontano?', es: '¿Está lejos?', 'pt-BR': 'É longe?', el: 'Είναι μακριά;' },
      { ru: 'Покажите на карте', en: 'Show me on the map', de: 'Zeigen Sie mir auf der Karte', fr: 'Montrez-moi sur la carte', it: 'Me lo mostri sulla mappa', es: 'Muéstreme en el mapa', 'pt-BR': 'Mostre-me no mapa', el: 'Δείξτε μου στον χάρτη' },
    ]
  },
  numbers: {
    icon: '🔢',
    name: { ru: 'Числа и время', en: 'Numbers & Time' },
    phrases: [
      { ru: 'Который час?', en: 'What time is it?', de: 'Wie spät ist es?', fr: 'Quelle heure est-il?', it: 'Che ora è?', es: '¿Qué hora es?', 'pt-BR': 'Que horas são?', el: 'Τι ώρα είναι;' },
      { ru: 'Сегодня', en: 'Today', de: 'Heute', fr: "Aujourd'hui", it: 'Oggi', es: 'Hoy', 'pt-BR': 'Hoje', el: 'Σήμερα' },
      { ru: 'Завтра', en: 'Tomorrow', de: 'Morgen', fr: 'Demain', it: 'Domani', es: 'Mañana', 'pt-BR': 'Amanhã', el: 'Αύριο' },
      { ru: 'Вчера', en: 'Yesterday', de: 'Gestern', fr: 'Hier', it: 'Ieri', es: 'Ayer', 'pt-BR': 'Ontem', el: 'Χθες' },
      { ru: 'Один', en: 'One', de: 'Eins', fr: 'Un', it: 'Uno', es: 'Uno', 'pt-BR': 'Um', el: 'Ένα' },
      { ru: 'Два', en: 'Two', de: 'Zwei', fr: 'Deux', it: 'Due', es: 'Dos', 'pt-BR': 'Dois', el: 'Δύο' },
      { ru: 'Три', en: 'Three', de: 'Drei', fr: 'Trois', it: 'Tre', es: 'Tres', 'pt-BR': 'Três', el: 'Τρία' },
      { ru: 'Десять', en: 'Ten', de: 'Zehn', fr: 'Dix', it: 'Dieci', es: 'Diez', 'pt-BR': 'Dez', el: 'Δέκα' },
      { ru: 'Сто', en: 'One hundred', de: 'Hundert', fr: 'Cent', it: 'Cento', es: 'Cien', 'pt-BR': 'Cem', el: 'Εκατό' },
      { ru: 'Тысяча', en: 'One thousand', de: 'Tausend', fr: 'Mille', it: 'Mille', es: 'Mil', 'pt-BR': 'Mil', el: 'Χίλια' },
    ]
  }
};

let currentPhrasebookCategory = 'custom';
let pbSourceLang = 'ru';
let pbTargetLang = 'en';

// Category names in all supported languages
const PB_CATEGORY_NAMES = {
  greetings:  { ru: 'Приветствия', en: 'Greetings', de: 'Begrüßung', fr: 'Salutations', it: 'Saluti', es: 'Saludos', 'pt-BR': 'Saudações', el: 'Χαιρετισμοί' },
  restaurant: { ru: 'Ресторан', en: 'Restaurant', de: 'Restaurant', fr: 'Restaurant', it: 'Ristorante', es: 'Restaurante', 'pt-BR': 'Restaurante', el: 'Εστιατόριο' },
  hotel:      { ru: 'Отель', en: 'Hotel', de: 'Hotel', fr: 'Hôtel', it: 'Hotel', es: 'Hotel', 'pt-BR': 'Hotel', el: 'Ξενοδοχείο' },
  transport:  { ru: 'Транспорт', en: 'Transport', de: 'Transport', fr: 'Transport', it: 'Trasporto', es: 'Transporte', 'pt-BR': 'Transporte', el: 'Μεταφορά' },
  shopping:   { ru: 'Магазин', en: 'Shopping', de: 'Einkaufen', fr: 'Shopping', it: 'Shopping', es: 'Compras', 'pt-BR': 'Compras', el: 'Αγορές' },
  emergency:  { ru: 'Экстренные', en: 'Emergency', de: 'Notfall', fr: 'Urgence', it: 'Emergenza', es: 'Emergencia', 'pt-BR': 'Emergência', el: 'Έκτακτη ανάγκη' },
  navigation: { ru: 'Навигация', en: 'Navigation', de: 'Navigation', fr: 'Navigation', it: 'Navigazione', es: 'Navegación', 'pt-BR': 'Navegação', el: 'Πλοήγηση' },
  numbers:    { ru: 'Числа и время', en: 'Numbers & Time', de: 'Zahlen & Zeit', fr: 'Nombres & Heure', it: 'Numeri & Ora', es: 'Números y Hora', 'pt-BR': 'Números e Hora', el: 'Αριθμοί & Ώρα' }
};

function togglePhrasebook() {
  const main = document.getElementById('mainView');
  const hist = document.getElementById('historyView');
  const pb = document.getElementById('phrasebookView');
  const isOpen = pb.classList.contains('visible');
  if (isOpen) {
    pb.classList.remove('visible');
    main.style.display = '';
    hideAddPhraseForm();
  } else {
    // Sync phrasebook langs with main lang bar on open
    pbSourceLang = sourceLang;
    pbTargetLang = targetLang;
    document.getElementById('pbLangFrom').value = pbSourceLang;
    document.getElementById('pbLangTo').value = pbTargetLang;

    main.style.display = 'none';
    hist.classList.remove('visible');
    pb.classList.add('visible');
    // Always open on "Мои фразы"
    currentPhrasebookCategory = 'custom';
    updatePhrasebookLangUI();
    renderPhrasebookCategories();
    if (!customPhrasesLoaded) loadCustomPhrases();
    else renderPhrasebookView();
  }
}

function updatePhrasebookLangs() {
  pbSourceLang = document.getElementById('pbLangFrom').value;
  pbTargetLang = document.getElementById('pbLangTo').value;
  if (pbSourceLang === pbTargetLang) {
    const keys = Object.keys(LANGS);
    const alt = keys.find(k => k !== pbSourceLang);
    pbTargetLang = alt;
    document.getElementById('pbLangTo').value = alt;
  }
  updatePhrasebookLangUI();
  renderPhrasebookCategories();
  renderPhrasebookView();
  hideAddPhraseForm();
}

function swapPhrasebookLangs() {
  const tmp = pbSourceLang;
  pbSourceLang = pbTargetLang;
  pbTargetLang = tmp;
  document.getElementById('pbLangFrom').value = pbSourceLang;
  document.getElementById('pbLangTo').value = pbTargetLang;
  updatePhrasebookLangUI();
  renderPhrasebookCategories();
  renderPhrasebookView();
}

function updatePhrasebookLangUI() {
  document.getElementById('pbLangFromFlag').innerHTML = flagImg(LANGS[pbSourceLang].flagCode);
  document.getElementById('pbLangToFlag').innerHTML = flagImg(LANGS[pbTargetLang].flagCode);
  document.getElementById('pbLangFromLabel').textContent = LANGS[pbSourceLang].name;
  document.getElementById('pbLangToLabel').textContent = LANGS[pbTargetLang].name;
}

function renderPhrasebookCategories() {
  // Update the selector button text to reflect current category
  const btn = document.getElementById('pbCategorySelectorText');
  if (currentPhrasebookCategory === 'custom') {
    btn.textContent = 'Мои фразы';
  } else {
    const cat = PHRASEBOOK[currentPhrasebookCategory];
    if (cat) {
      const catNames = PB_CATEGORY_NAMES[currentPhrasebookCategory] || cat.name;
      const label = catNames[pbSourceLang] || catNames.ru || catNames.en;
      btn.textContent = cat.icon + ' ' + label;
    }
  }
}

function togglePbMainCategoryPopup() {
  const popup = document.getElementById('pbMainCategoryPopup');
  if (popup.classList.contains('visible')) {
    popup.classList.remove('visible');
    return;
  }

  popup.innerHTML = '';

  // "Мои фразы" option first
  const customOpt = document.createElement('button');
  customOpt.className = 'pb-main-category-option' + (currentPhrasebookCategory === 'custom' ? ' active' : '');
  customOpt.textContent = 'Мои фразы';
  customOpt.onclick = () => selectPbMainCategory('custom', 'Мои фразы');
  popup.appendChild(customOpt);

  // All PHRASEBOOK categories
  for (const [key, cat] of Object.entries(PHRASEBOOK)) {
    const opt = document.createElement('button');
    opt.className = 'pb-main-category-option' + (currentPhrasebookCategory === key ? ' active' : '');
    const catNames = PB_CATEGORY_NAMES[key] || cat.name;
    const label = catNames[pbSourceLang] || catNames.ru || catNames.en;
    opt.textContent = cat.icon + ' ' + label;
    opt.onclick = () => selectPbMainCategory(key, cat.icon + ' ' + label);
    popup.appendChild(opt);
  }

  popup.classList.add('visible');
}

function selectPbMainCategory(key, label) {
  currentPhrasebookCategory = key;
  document.getElementById('pbCategorySelectorText').textContent = label;
  document.getElementById('pbMainCategoryPopup').classList.remove('visible');
  renderPhrasebookView();
}

function renderPhrasebookView() {
  const isCustom = currentPhrasebookCategory === 'custom';
  // Show/hide "Мои фразы" section and add button only in custom view
  document.getElementById('pbCustomSection').style.display = '';
  document.getElementById('pbAddBtn').style.display = '';

  if (isCustom) {
    renderCustomPhrases();
    // Clear the built-in phrase list
    document.getElementById('phrasebookList').innerHTML = '';
  } else {
    // Hide "Мои фразы" header section in category view
    document.getElementById('pbCustomSection').style.display = 'none';
    renderPhrasebookPhrases();
  }
}

function renderPhrasebookPhrases() {
  const container = document.getElementById('phrasebookList');
  container.innerHTML = '';
  const cat = PHRASEBOOK[currentPhrasebookCategory];
  if (!cat) return;

  const src = pbSourceLang;
  const tgt = pbTargetLang;
  const tgtTtsLang = LANGS[tgt] ? LANGS[tgt].tts : 'en-US';
  const srcTtsLang = LANGS[src] ? LANGS[src].tts : 'ru-RU';

  // First: render custom phrases assigned to this category (at the top)
  const catCustom = customPhrases.filter(p =>
    p.category === currentPhrasebookCategory &&
    ((p.source_lang === src && p.target_lang === tgt) ||
     (p.source_lang === tgt && p.target_lang === src))
  );

  catCustom.forEach(p => {
    let srcText, tgtText;
    if (p.source_lang === src) { srcText = p.source_text; tgtText = p.target_text; }
    else { srcText = p.target_text; tgtText = p.source_text; }

    const item = document.createElement('div');
    item.className = 'phrasebook-item';
    const escapedTgt = tgtText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
    const escapedSrc = srcText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
    const phraseId = (p.id || '').replace(/'/g, '');

    item.innerHTML =
      '<div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">' +
        '<div style="flex:1">' +
          '<div class="phrasebook-item-source">' + escapeHtml(srcText) + ' <span class="pb-custom-badge">моя</span></div>' +
          '<div class="phrasebook-item-target">' + escapeHtml(tgtText) + '</div>' +
        '</div>' +
      '</div>' +
      '<div class="phrasebook-item-actions">' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedSrc + '\', \'' + srcTtsLang + '\', this)" title="Озвучить оригинал" style="color:var(--terracotta)">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedTgt + '\', \'' + tgtTtsLang + '\', this)" title="Озвучить перевод">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="copyPhrase(\'' + escapedTgt + '\')" title="Копировать">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>' +
        '</button>' +
        '<button class="pb-item-delete" onclick="deleteCustomPhrase(\'' + phraseId + '\')" title="Удалить">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>' +
        '</button>' +
      '</div>';

    container.appendChild(item);
  });

  // Then: render built-in phrases
  cat.phrases.forEach(phrase => {
    const srcText = phrase[src] || phrase.en || '';
    const tgtText = phrase[tgt] || phrase.en || '';
    if (!srcText || !tgtText) return;

    const item = document.createElement('div');
    item.className = 'phrasebook-item';

    const escapedTgt = tgtText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
    const escapedSrc = srcText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');

    item.innerHTML =
      '<div class="phrasebook-item-source">' + escapeHtml(srcText) + '</div>' +
      '<div class="phrasebook-item-target">' + escapeHtml(tgtText) + '</div>' +
      '<div class="phrasebook-item-actions">' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedSrc + '\', \'' + srcTtsLang + '\', this)" title="Озвучить оригинал" style="color:var(--terracotta)">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedTgt + '\', \'' + tgtTtsLang + '\', this)" title="Озвучить перевод">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="copyPhrase(\'' + escapedTgt + '\')" title="Копировать перевод">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>' +
        '</button>' +
      '</div>';

    container.appendChild(item);
  });

}

function speakPhrase(text, lang, btn) {
  // Use browser TTS directly for phrasebook (works offline)
  if (currentSource || ttsPlaying || (window.speechSynthesis && window.speechSynthesis.speaking)) {
    stopAudio();
    return;
  }
  if (isOffline) {
    speakWithBrowserTTS(text, lang, btn);
  } else {
    speakText(text, lang, btn);
  }
}

function speakWithBrowserTTS(text, lang, btn) {
  if (!('speechSynthesis' in window)) {
    showToast('Синтез речи недоступен');
    return;
  }
  clearSpeakingState();
  if (btn) btn.classList.add('speaking');
  showGlobalStop();

  const u = new SpeechSynthesisUtterance(text);
  u.lang = lang;
  u.rate = 0.9;

  const baseLang = lang.split('-')[0];
  const voices = window.speechSynthesis.getVoices();
  const match = voices.find(v => v.lang === lang)
    || voices.find(v => v.lang.startsWith(baseLang + '-'))
    || voices.find(v => v.lang.startsWith(baseLang));
  if (match) {
    u.voice = match;
    u.lang = match.lang;
  }
  u.onend = () => clearSpeakingState();
  u.onerror = () => clearSpeakingState();
  window.speechSynthesis.speak(u);
}

function copyPhrase(text) {
  navigator.clipboard.writeText(text).then(() => showToast('Скопировано')).catch(() => {});
}

// ===== CUSTOM PHRASES =====
let customPhrases = [];
let customPhrasesLoaded = false;
let pbAddTranslateTimer = null;
let pbAddSelectedCategory = 'custom';

async function loadCustomPhrases() {
  // Load from IndexedDB first (instant, works offline)
  customPhrases = await getCustomPhrasesFromDB();
  renderPhrasebookView();

  // Then sync from server if online
  if (!isOffline && authToken) {
    try {
      const res = await fetch('/api/phrasebook/list', { headers: getAuthHeaders() });
      if (res.ok) {
        const data = await res.json();
        customPhrases = data.phrases || [];
        await saveCustomPhrasesToDB(customPhrases);
        renderPhrasebookView();
      }
    } catch (e) { /* offline or error — use cached */ }
  }
  customPhrasesLoaded = true;
}

function renderCustomPhrases() {
  const section = document.getElementById('pbCustomSection');
  const list = document.getElementById('pbCustomList');
  const countEl = document.getElementById('pbCustomCount');

  // Filter phrases: only "Мои фразы" (custom category) matching current language pair
  const filtered = customPhrases.filter(p =>
    (p.category === 'custom' || !p.category) &&
    ((p.source_lang === pbSourceLang && p.target_lang === pbTargetLang) ||
    (p.source_lang === pbTargetLang && p.target_lang === pbSourceLang))
  );

  countEl.textContent = filtered.length;

  if (filtered.length === 0) {
    section.style.display = 'none';
    list.innerHTML = '';
    return;
  }

  section.style.display = 'block';
  list.innerHTML = '';

  filtered.forEach(phrase => {
    // Show in correct direction — if stored reversed, flip display
    let srcText, tgtText;
    if (phrase.source_lang === pbSourceLang) {
      srcText = phrase.source_text;
      tgtText = phrase.target_text;
    } else {
      srcText = phrase.target_text;
      tgtText = phrase.source_text;
    }

    const item = document.createElement('div');
    item.className = 'phrasebook-item';

    const escapedTgt = tgtText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
    const escapedSrc = srcText.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');
    const tgtTtsLang = LANGS[pbTargetLang] ? LANGS[pbTargetLang].tts : 'en-US';
    const srcTtsLang = LANGS[pbSourceLang] ? LANGS[pbSourceLang].tts : 'ru-RU';
    const phraseId = (phrase.id || '').replace(/'/g, '');

    item.innerHTML =
      '<div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">' +
        '<div style="flex:1">' +
          '<div class="phrasebook-item-source">' + escapeHtml(srcText) + ' <span class="pb-custom-badge">моя</span></div>' +
          '<div class="phrasebook-item-target">' + escapeHtml(tgtText) + '</div>' +
        '</div>' +
      '</div>' +
      '<div class="phrasebook-item-actions">' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedSrc + '\', \'' + srcTtsLang + '\', this)" title="Озвучить оригинал" style="color:var(--terracotta)">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="speakPhrase(\'' + escapedTgt + '\', \'' + tgtTtsLang + '\', this)" title="Озвучить перевод">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>' +
        '</button>' +
        '<button class="icon-btn" onclick="copyPhrase(\'' + escapedTgt + '\')" title="Копировать">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>' +
        '</button>' +
        '<button class="pb-item-delete" onclick="deleteCustomPhrase(\'' + phraseId + '\')" title="Удалить">' +
          '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>' +
        '</button>' +
      '</div>';

    list.appendChild(item);
  });
}

// Auto-translate source phrase with debounce
function onPbAddSourceInput() {
  const tgtInput = document.getElementById('pbAddTarget');
  const hint = document.getElementById('pbAddTranslateHint');
  clearTimeout(pbAddTranslateTimer);

  // If user manually edited target, don't overwrite
  if (tgtInput.dataset.manualEdit) {
    if (hint) hint.textContent = '';
    return;
  }

  const text = document.getElementById('pbAddSource').value.trim();
  if (!text) {
    tgtInput.value = '';
    if (hint) hint.textContent = '';
    return;
  }

  if (hint) hint.textContent = 'Перевожу...';
  pbAddTranslateTimer = setTimeout(async () => {
    try {
      const prompt = 'You are a translator. Translate from ' + (LANGS[pbSourceLang] ? LANGS[pbSourceLang].name : 'source') + ' to ' + (LANGS[pbTargetLang] ? LANGS[pbTargetLang].name : 'target') + '. Reply ONLY with the translation, nothing else. No quotes, no explanation.';
      const result = await callTranslate(prompt, text, 256);
      if (result && !tgtInput.dataset.manualEdit) {
        tgtInput.value = result.trim().replace(/^["']|["']$/g, '');
      }
      if (hint) hint.textContent = '';
    } catch (e) {
      if (hint) hint.textContent = '';
    }
  }, 700);
}

// Category popup for add phrase form
function togglePbCategoryPopup() {
  const popup = document.getElementById('pbAddCategoryPopup');
  if (popup.classList.contains('visible')) {
    popup.classList.remove('visible');
    return;
  }

  popup.innerHTML = '';

  // "Мои фразы" first
  const customOpt = document.createElement('button');
  customOpt.className = 'pb-add-category-option' + (pbAddSelectedCategory === 'custom' ? ' active' : '');
  customOpt.textContent = 'Мои фразы';
  customOpt.onclick = () => selectPbCategory('custom', 'Мои фразы');
  popup.appendChild(customOpt);

  // All PHRASEBOOK categories
  for (const [key, cat] of Object.entries(PHRASEBOOK)) {
    const opt = document.createElement('button');
    opt.className = 'pb-add-category-option' + (pbAddSelectedCategory === key ? ' active' : '');
    const catNames = PB_CATEGORY_NAMES[key] || cat.name;
    const label = catNames[pbSourceLang] || catNames.ru || catNames.en;
    opt.textContent = cat.icon + ' ' + label;
    opt.onclick = () => selectPbCategory(key, cat.icon + ' ' + label);
    popup.appendChild(opt);
  }

  popup.classList.add('visible');
}

function selectPbCategory(key, label) {
  pbAddSelectedCategory = key;
  document.getElementById('pbAddCategoryText').textContent = label;
  document.getElementById('pbAddCategoryPopup').classList.remove('visible');
}

// Close category popups on outside click
document.addEventListener('click', function(e) {
  // Add-form category popup
  const addPopup = document.getElementById('pbAddCategoryPopup');
  const addBtn = document.getElementById('pbAddCategoryBtn');
  if (addPopup && addBtn && !addPopup.contains(e.target) && !addBtn.contains(e.target)) {
    addPopup.classList.remove('visible');
  }
  // Main category selector popup
  const mainPopup = document.getElementById('pbMainCategoryPopup');
  const mainBtn = document.getElementById('pbCategorySelectorBtn');
  if (mainPopup && mainBtn && !mainPopup.contains(e.target) && !mainBtn.contains(e.target)) {
    mainPopup.classList.remove('visible');
  }
});

function showAddPhraseForm() {
  const form = document.getElementById('pbAddForm');
  const srcInput = document.getElementById('pbAddSource');
  const tgtInput = document.getElementById('pbAddTarget');
  form.classList.add('visible');
  document.getElementById('pbAddBtn').style.display = 'none';

  // Update placeholders with current language names
  srcInput.placeholder = LANGS[pbSourceLang] ? LANGS[pbSourceLang].name : 'Оригинал';
  tgtInput.placeholder = LANGS[pbTargetLang] ? LANGS[pbTargetLang].name : 'Перевод';
  srcInput.value = '';
  tgtInput.value = '';
  delete tgtInput.dataset.manualEdit;
  document.getElementById('pbAddTranslateHint').textContent = '';
  // Reset category to default
  pbAddSelectedCategory = 'custom';
  document.getElementById('pbAddCategoryText').textContent = 'Мои фразы';
  document.getElementById('pbAddCategoryPopup').classList.remove('visible');
  srcInput.focus();
}

function hideAddPhraseForm() {
  document.getElementById('pbAddForm').classList.remove('visible');
  document.getElementById('pbAddBtn').style.display = '';
  clearTimeout(pbAddTranslateTimer);
  document.getElementById('pbAddCategoryPopup').classList.remove('visible');
}

async function saveCustomPhrase() {
  const srcText = document.getElementById('pbAddSource').value.trim();
  const tgtText = document.getElementById('pbAddTarget').value.trim();

  if (!srcText || !tgtText) {
    showToast('Заполните оба поля');
    return;
  }

  const phrase = {
    category: pbAddSelectedCategory,
    source_lang: pbSourceLang,
    target_lang: pbTargetLang,
    source_text: srcText,
    target_text: tgtText,
    created_at: new Date().toISOString()
  };

  // Save to server if online
  if (!isOffline && authToken) {
    try {
      const res = await fetch('/api/phrasebook/add', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify(phrase)
      });
      if (res.ok) {
        const data = await res.json();
        if (data.phrase) {
          phrase.id = data.phrase.id;
        }
      }
    } catch (e) { /* save locally anyway */ }
  }

  // Generate local ID if server didn't provide one
  if (!phrase.id) {
    phrase.id = 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
  }

  customPhrases.unshift(phrase);
  await saveCustomPhrasesToDB(customPhrases);
  renderPhrasebookView();
  hideAddPhraseForm();
  showToast('Фраза сохранена');
}

async function deleteCustomPhrase(id) {
  if (!id) return;

  // Delete from server if online and it's a server-side phrase
  if (!isOffline && authToken && !id.startsWith('local_')) {
    try {
      await fetch('/api/phrasebook/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify({ id })
      });
    } catch (e) { /* delete locally anyway */ }
  }

  customPhrases = customPhrases.filter(p => p.id !== id);
  await saveCustomPhrasesToDB(customPhrases);
  renderPhrasebookView();
  showToast('Фраза удалена');
}

// ===== SAVE RESULT TO PHRASEBOOK =====
async function saveResultToPhrasebook(mode) {
  let sourceText, translatedText, srcLang, tgtLang, btnId;

  if (mode === 'text') {
    const el = document.getElementById('textResultText');
    sourceText = el.dataset.sourceText;
    translatedText = el.textContent;
    srcLang = el.dataset.sourceLang;
    tgtLang = el.dataset.targetLang;
    btnId = 'textSavePhraseBtn';
  } else if (mode === 'voice') {
    const el = document.getElementById('voiceResultText');
    sourceText = el.dataset.sourceText;
    translatedText = el.textContent;
    srcLang = el.dataset.sourceLang;
    tgtLang = el.dataset.targetLang;
    btnId = 'voiceSavePhraseBtn';
  }

  if (!sourceText || !translatedText || !srcLang || !tgtLang) {
    showToast('Нечего сохранить');
    return;
  }

  // Check for duplicates
  const exists = customPhrases.some(p =>
    p.source_lang === srcLang && p.target_lang === tgtLang &&
    p.source_text.trim().toLowerCase() === sourceText.trim().toLowerCase()
  );
  if (exists) {
    showToast('Эта фраза уже в разговорнике');
    if (btnId) document.getElementById(btnId).classList.add('saved');
    return;
  }

  const phrase = {
    category: 'custom',
    source_lang: srcLang,
    target_lang: tgtLang,
    source_text: sourceText,
    target_text: translatedText,
    created_at: new Date().toISOString()
  };

  // Save to server if online
  if (!isOffline && authToken) {
    try {
      const res = await fetch('/api/phrasebook/add', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify(phrase)
      });
      if (res.ok) {
        const data = await res.json();
        if (data.phrase) phrase.id = data.phrase.id;
      }
    } catch (e) { /* save locally anyway */ }
  }

  if (!phrase.id) {
    phrase.id = 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
  }

  customPhrases.unshift(phrase);
  await saveCustomPhrasesToDB(customPhrases);

  if (btnId) document.getElementById(btnId).classList.add('saved');
  showToast('Сохранено в разговорник');
}

// ===== OFFLINE-AWARE TRANSLATION =====
// Patch translateText to check local cache when offline
const _origTranslateText = translateText;
translateText = async function() {
  if (!isOffline) { return _origTranslateText(); }

  const text = document.getElementById('textInput').value.trim();
  if (!text) return;

  const btn = document.getElementById('textTranslateBtn');
  btn.disabled = true; btn.textContent = '...';

  const resultEl = document.getElementById('textResultText');

  // Try to find in local cache
  const cached = await findCachedTranslation(sourceLang, targetLang, text);
  if (cached) {
    resultEl.textContent = cached.translated_text;
    resultEl.dataset.lang = LANGS[targetLang].tts;
    resultEl.dataset.sourceLang = sourceLang;
    resultEl.dataset.targetLang = targetLang;
    resultEl.dataset.sourceText = text;
    document.getElementById('textResultLabel').textContent = LANGS[targetLang].name;
    document.getElementById('textResult').classList.add('visible');
    document.getElementById('textSavePhraseBtn').classList.remove('saved');
    showToast('Найдено в кэше (оффлайн)');
  } else {
    // Also try reverse direction
    const cachedReverse = await findCachedTranslation(targetLang, sourceLang, text);
    if (cachedReverse) {
      resultEl.textContent = cachedReverse.translated_text;
      resultEl.dataset.lang = LANGS[sourceLang].tts;
      resultEl.dataset.sourceLang = targetLang;
      resultEl.dataset.targetLang = sourceLang;
      resultEl.dataset.sourceText = text;
      document.getElementById('textResultLabel').textContent = LANGS[sourceLang].name;
      document.getElementById('textResult').classList.add('visible');
      document.getElementById('textSavePhraseBtn').classList.remove('saved');
      showToast('Найдено в кэше (оффлайн)');
    } else {
      // Check phrasebook
      const pbResult = findInPhrasebook(text, sourceLang, targetLang);
      if (pbResult) {
        resultEl.textContent = pbResult;
        resultEl.dataset.lang = LANGS[targetLang].tts;
        resultEl.dataset.sourceLang = sourceLang;
        resultEl.dataset.targetLang = targetLang;
        resultEl.dataset.sourceText = text;
        document.getElementById('textResultLabel').textContent = LANGS[targetLang].name;
        document.getElementById('textResult').classList.add('visible');
        document.getElementById('textSavePhraseBtn').classList.remove('saved');
        showToast('Найдено в разговорнике (оффлайн)');
      } else {
        showToast('Нет интернета. Перевод недоступен. Используйте разговорник.');
      }
    }
  }

  btn.disabled = false; btn.textContent = 'Перевести';
};

function findInPhrasebook(text, srcLang, tgtLang) {
  const needle = text.trim().toLowerCase().replace(/[.!?;,]$/, '');
  // Search built-in phrasebook
  for (const cat of Object.values(PHRASEBOOK)) {
    for (const phrase of cat.phrases) {
      const src = (phrase[srcLang] || '').toLowerCase().replace(/[.!?;,]$/, '');
      if (src && src === needle) {
        return phrase[tgtLang] || null;
      }
    }
  }
  // Search custom phrases
  for (const phrase of customPhrases) {
    if (phrase.source_lang === srcLang && phrase.target_lang === tgtLang) {
      if (phrase.source_text.trim().toLowerCase().replace(/[.!?;,]$/, '') === needle) {
        return phrase.target_text;
      }
    }
    if (phrase.source_lang === tgtLang && phrase.target_lang === srcLang) {
      if (phrase.target_text.trim().toLowerCase().replace(/[.!?;,]$/, '') === needle) {
        return phrase.source_text;
      }
    }
  }
  return null;
}

// ===== OFFLINE-AWARE TTS =====
// Patch speakText to use browser TTS when offline
const _origSpeakText = speakText;
speakText = async function(text, lang, btn, genderOverride) {
  if (isOffline) {
    speakWithBrowserTTS(text, lang, btn);
    return;
  }
  return _origSpeakText(text, lang, btn, genderOverride);
};

// ===== OFFLINE-AWARE HISTORY =====
// Patch loadHistory to show cached translations when offline
const _origLoadHistory = loadHistory;
loadHistory = async function() {
  if (!isOffline) { return _origLoadHistory(); }

  const list = document.getElementById('historyList');
  list.innerHTML = '<div style="text-align:center;padding:20px 0;color:var(--muted);font-size:13px">Загрузка из кэша...</div>';
  document.getElementById('historyLoadMore').classList.add('hidden');

  const cached = await getRecentCachedTranslations(50);
  list.innerHTML = '';

  if (cached.length === 0) {
    list.innerHTML = renderHistoryEmpty('Кэш пуст', 'Переводы появятся здесь после использования с интернетом');
    return;
  }

  cached.forEach(t => {
    const el = document.createElement('div');
    el.className = 'history-item';
    const date = new Date(t.created_at).toLocaleString('ru-RU', { day:'numeric', month:'short', hour:'2-digit', minute:'2-digit' });
    const modeNames = { text: 'Текст', photo: 'Фото', voice: 'Голос', file: 'Файл' };
    el.innerHTML = '<div class="history-item-header"><span class="history-item-mode">' + (modeNames[t.mode] || t.mode) + '</span><span class="history-item-date">' + date + ' (кэш)</span></div>' +
      '<div class="history-item-source">' + escapeHtml((t.source_text_original || t.source_text || '').substring(0, 200)) + '</div>' +
      '<div class="history-item-text">' + escapeHtml((t.translated_text || '').substring(0, 300)) + '</div>' +
      '<div class="history-item-langs">' + (t.source_lang || '') + ' → ' + (t.target_lang || '') + '</div>';
    list.appendChild(el);
  });
};

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
